<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-WNH50QZ2NX"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
    
      gtag('config', 'G-WNH50QZ2NX');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hexagon Puzzle Solver</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: #111827; /* bg-gray-900 */
            color: #f3f4f6; /* text-gray-200 */
            margin: 0;
            padding: 2rem 0;
        }
        .container {
            text-align: center;
            background-color: #1f2937; /* bg-gray-800 */
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            width: 95%;
            max-width: 1400px;
        }
        canvas {
            background-color: #374151; /* bg-gray-700 */
            border-radius: 0.75rem;
            margin-top: 1.5rem;
        }
        h1 {
            font-size: 2.25rem;
            font-weight: 600;
            color: #34d399; /* text-green-400 */
        }
        p {
            font-size: 1.125rem;
            color: #9ca3af; /* text-gray-400 */
        }
        #score, #score2 {
            font-size: 1.5rem;
            font-weight: 600;
            color: #34d399; /* text-green-400 */
            margin-top: 1rem;
            min-height: 2.25rem; /* Reserve space to prevent layout shift */
        }
        select, button {
            transition: all 0.2s ease-in-out;
        }
        #progress-bar, #progress-bar2 {
            transition: width 0.2s ease-out;
        }
        .control-group {
            margin-bottom: 1rem;
        }
        .results-summary {
            color: #9ca3af;
            font-style: italic;
            margin-top: 0.5rem;
        }
        .layout-container {
            border: 1px solid #374151;
            border-radius: 0.75rem;
            padding: 1rem;
            cursor: pointer;
            transition: border-color 0.2s ease-in-out;
        }
        .layout-container.selected {
            border-color: #34d399; /* green-400 */
            box-shadow: 0 0 10px rgba(52, 211, 153, 0.4);
        }
        #hexagon-list .hex-container canvas {
            transition: all 0.2s ease-in-out;
        }
        #hexagon-list .hex-container.selected canvas {
            border-color: #34d399; /* green-400 */
            box-shadow: 0 0 15px rgba(52, 211, 153, 0.8);
            border-width: 4px;
            transform: scale(1.05);
        }
    </style>
</head>
<body>

    <div class="container">
        <h1 class="text-xl font-semibold">Hexagon Grid Master</h1>
        <p>Find the optimal arrangement of hexagons in a 2-3-2 layout.</p>

        <div id="data-management" class="mt-8 border-t border-gray-700 pt-8">
            <h2 class="text-xl font-semibold text-gray-300">Manage Hexagon Data</h2>
            
            <!-- Add Shape Form -->
            <div id="add-shape-form" class="my-4 p-4 border border-gray-600 rounded-lg">
                <h3 class="text-lg font-semibold text-gray-300 mb-2">Add a New Hexagon</h3>
                <p class="text-sm text-gray-500 mt-1 mb-4">Define the properties of a hexagon piece and add it to your pool. You can also add random pieces for quick testing.</p>
                <div class="grid grid-cols-1 md:grid-cols-4 gap-4">
                    <div>
                        <label for="new-hex-id" class="block text-sm font-medium text-gray-400">ID</label>
                        <input type="number" id="new-hex-id" class="mt-1 block w-full bg-gray-800 border border-gray-600 rounded-md p-2 text-white" disabled/>
                    </div>
                    <div>
                        <label for="new-hex-label" class="block text-sm font-medium text-gray-400">Label</label>
                        <input type="text" id="new-hex-label" class="mt-1 block w-full bg-gray-700 border border-gray-600 rounded-md p-2 text-white"/>
                    </div>
                    <div>
                        <label for="new-hex-rarity" class="block text-sm font-medium text-gray-400">Rarity</label>
                        <select id="new-hex-rarity" class="mt-1 block w-full bg-gray-700 border border-gray-600 rounded-md p-2 text-white"></select>
                    </div>
                    <div>
                        <label for="new-hex-element" class="block text-sm font-medium text-gray-400">Element</label>
                        <select id="new-hex-element" class="mt-1 block w-full bg-gray-700 border border-gray-600 rounded-md p-2 text-white"></select>
                    </div>
                </div>
                <div class="mt-4">
                    <label class="block text-sm font-medium text-gray-400">Sides (Top-Left, Top-Right, Right, Bottom-Right, Bottom-Left, Left)</label>
                    <div id="new-hex-sides" class="grid grid-cols-6 gap-2 mt-1"></div>
                </div>
                <button id="add-shape-button" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md mt-4">Add Shape</button>
                <button id="add-random-shape-button" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md mt-4">Add Random Shape</button>
            </div>

            <h3 class="text-lg font-semibold text-gray-300">Current Hexagons</h3>
            <p class="text-sm text-gray-500 mt-1">From your pool below, click to select up to 7 hexagons to be used in the puzzle. Selected pieces are highlighted in green. You can click a piece again to deselect it, or click the 'X' to permanently delete it from the pool.</p>
            <div id="hexagon-list" class="flex flex-wrap justify-center gap-4 p-4 bg-gray-900 rounded-lg mt-2"></div>
        </div>
        
        <div class="my-4 flex flex-col items-center justify-center gap-4">
            <div class="control-group">
                <label for="center-piece-select" class="mr-2 text-gray-400">Center Piece (M2):</label>
                <select id="center-piece-select" class="bg-gray-700 border border-gray-600 text-white rounded-md p-2 focus:ring-2 focus:ring-blue-500 focus:outline-none">
                </select>
                <p class="text-sm text-gray-500 mt-1">Optionally, lock a specific piece in the center position (M2) to speed up the search.</p>
            </div>
            <div class="control-group flex items-center gap-4">
                <span class="text-gray-400">Search Mode:</span>
                <label class="flex items-center"><input type="radio" name="search-mode" value="bestScore" checked class="form-radio h-4 w-4 text-blue-600 bg-gray-700 border-gray-600 focus:ring-blue-500"> <span class="ml-2">Find Best Score</span></label>
                <label class="flex items-center"><input type="radio" name="search-mode" value="stopAt12" class="form-radio h-4 w-4 text-blue-600 bg-gray-700 border-gray-600 focus:ring-blue-500"> <span class="ml-2">Stop at 12</span></label>
            </div>
            <fieldset id="tiebreak-fieldset" class="control-group" disabled>
                <span class="text-gray-400">Tie-Breaking Strategy:</span>
                <p class="text-sm text-gray-500 mt-1">When multiple layouts share the same top score, this determines how they are sorted. You can prioritize by the total rarity of pieces, the number of matches of a specific color, or the number of pieces of a specific element.</p>
                <div class="flex items-center justify-center gap-4 mt-2">
                    <label class="flex items-center"><input type="radio" name="tiebreak-mode" value="rarity" checked class="form-radio h-4 w-4 text-blue-600 bg-gray-700 border-gray-600 focus:ring-blue-500"> <span class="ml-2">Rarity</span></label>
                    <label class="flex items-center"><input type="radio" name="tiebreak-mode" value="color" class="form-radio h-4 w-4 text-blue-600 bg-gray-700 border-gray-600 focus:ring-blue-500"> <span class="ml-2">Color Priority</span></label>
                    <label class="flex items-center"><input type="radio" name="tiebreak-mode" value="element" class="form-radio h-4 w-4 text-blue-600 bg-gray-700 border-gray-600 focus:ring-blue-500"> <span class="ml-2">Element Priority</span></label>
                </div>
                <div id="color-priority-controls" class="control-group flex-wrap items-center justify-center gap-2 mt-2" style="display: none;">
                    <!-- Color priority dropdowns will be added here -->
                </div>
                <div id="element-priority-controls" class="control-group flex-wrap items-center justify-center gap-2 mt-2" style="display: none;">
                    <!-- Element priority dropdowns will be added here -->
                </div>
            </fieldset>
            <button id="solve-button" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md">Solve</button>
            <p class="text-sm text-gray-500 mt-1">This will start the search for the best arrangement using the selected hexagons.</p>
        </div>

        <div id="progress-container" class="w-full bg-gray-600 rounded-full h-2.5 mt-4" style="display: none;">
            <div id="progress-bar" class="bg-blue-500 h-2.5 rounded-full" style="width: 0%"></div>
        </div>
        <div id="progress-text" class="text-sm text-gray-400 mt-1"></div>
        <div id="estimation-text1" class="text-sm text-gray-400 mt-1"></div>
        <p class="text-xs text-yellow-400 mt-1">Note: The time estimation may be inaccurate for very large numbers of hexagons.</p>
        
        <div id="score"></div>
        <div id="results-summary1" class="results-summary"></div>
        <h2 id="grid1-title" class="text-xl font-semibold text-gray-300 mt-4" style="display: none;">Main Grid Results</h2>
        <div id="grid1-layouts" class="flex flex-wrap justify-center gap-4">
        </div>
        <div id="grid1-pagination" class="flex justify-center items-center mt-4"></div>
        <div class="my-4">
            <button id="solve-second-grid-button" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-md" style="display: none;" disabled>Solve Second Grid</button>
            <p id="solve-second-grid-hint" class="text-sm text-gray-500 mt-1" style="display: none;">After finding the first grid, select one of the resulting layouts above, then click here to find the best arrangement for a second grid using the remaining pieces.</p>
        </div>

        <div id="second-grid-container" class="mt-8 border-t border-gray-700 pt-8" style="display: none;">
             <div id="progress-container2" class="w-full bg-gray-600 rounded-full h-2.5 mt-4" style="display: none;">
                <div id="progress-bar2" class="bg-blue-500 h-2.5 rounded-full" style="width: 0%"></div>
            </div>
            <div id="progress-text2" class="text-sm text-gray-400 mt-1"></div>
            <div id="estimation-text2" class="text-sm text-gray-400 mt-1"></div>
             <div id="score2"></div>
             <div id="results-summary2" class="results-summary"></div>
             <div id="grid2-layouts" class="flex flex-wrap justify-center gap-4">
            </div>
            <div id="grid2-pagination" class="flex justify-center items-center mt-4"></div>
        </div>
    </div>

    <script>
        // --- Core Puzzle Logic ---
        const elements = ['normal', 'fire', 'water', 'wind', 'plant', 'mud', 'dark', 'light', 'ice', 'electric', 'poison'];
        const elementColors = {
            normal: '#A8A77A', fire: '#EE8130', water: '#6390F0', electric: '#F7D02C', plant: '#7AC74C',
            ice: '#96D9D6', mud: '#E2BF65', dark: '#705746', light: '#F85888', wind: '#A98FF3', poison: '#A040A0'
        };


        class Hexagon {
            constructor(id, label, rarity, sides, element) {
                this.id = id;
                this.label = label;
                this.rarity = rarity;
                this.sides = sides;
                this.element = element;
            }
        }

        // --- BigInt Arithmetic for Time Estimation ---
        function multiplyBigInt(num1, num2) {
            let a = num1.split('').reverse();
            let b = String(num2).split('').reverse();
            let result = [];

            for (let i = 0; i < a.length; i++) {
                for (let j = 0; j < b.length; j++) {
                    let index = i + j;
                    let product = a[i] * b[j];
                    result[index] = result[index] ? result[index] + product : product;
                }
            }

            for (let i = 0; i < result.length; i++) {
                if (result[i] >= 10) {
                    let carry = Math.floor(result[i] / 10);
                    result[i] %= 10;
                    result[i+1] = result[i+1] ? result[i+1] + carry : carry;
                }
            }
            return result.reverse().join('');
        }

        function divideBigInt(dividendStr, divisor) {
            let quotient = '';
            let remainder = 0;
            for (let i = 0; i < dividendStr.length; i++) {
                remainder = remainder * 10 + parseInt(dividendStr[i]);
                if (remainder >= divisor) {
                    quotient += Math.floor(remainder / divisor);
                    remainder %= divisor;
                } else {
                    if (quotient !== '') quotient += '0';
                }
            }
            return { quotient: quotient === '' ? '0' : quotient, remainder };
        }

        function formatSeconds(secondsStr) {
            if (secondsStr === '0') return 'less than a second';

            const divBy60 = divideBigInt(secondsStr, 60);
            const seconds = divBy60.remainder;
            const totalMinutesStr = divBy60.quotient;
            if (totalMinutesStr === '0') return `${seconds}s`;

            const divMinutesBy60 = divideBigInt(totalMinutesStr, 60);
            const minutes = divMinutesBy60.remainder;
            const totalHoursStr = divMinutesBy60.quotient;
            if (totalHoursStr === '0') return `${minutes}m ${seconds}s`;

            const divHoursBy24 = divideBigInt(totalHoursStr, 24);
            const hours = divHoursBy24.remainder;
            const days = divHoursBy24.quotient;
            if (days === '0') return `${hours}h ${minutes}m ${seconds}s`;
            
            return `${days}d ${hours}h ${minutes}m`;
        }

        function estimateTime(pieceCount, numToChoose) {
            if (pieceCount < numToChoose) return '0';
            let permutations = '1';
            for (let i = 0; i < numToChoose; i++) {
                permutations = multiplyBigInt(permutations, pieceCount - i);
            }
            const OPS_PER_SECOND = 500_000;
            return divideBigInt(permutations, OPS_PER_SECOND).quotient;
        }
        
        const rarityValue = { 'mythic': 5, 'legendary': 4, 'epic': 3, 'uncommon': 2, 'common': 1, 'none': 0 };

        function calculateRarityScore(arrangement) {
            return Object.values(arrangement).reduce((sum, hex) => sum + (rarityValue[hex.rarity] || 0), 0);
        }

        function calculateMatchScorePair(hex1, hex2, sideIndex1, sideIndex2) {
            if (!hex1 || !hex2) return { score: 0, color: null };
            const color1 = hex1.sides[sideIndex1];
            const color2 = hex2.sides[sideIndex2];
            if (color1 !== 'none' && color1 === color2) {
                return { score: 1, color: color1 };
            }
            return { score: 0, color: null };
        }

        function calculateArrangementScore(p) {
            let score = 0;
            const colorCounts = { red: 0, blue: 0, purple: 0, gray: 0, yellow: 0 };
            const elementCounts = Object.fromEntries(elements.map(e => [e, 0]));

            Object.values(p).forEach(hex => {
                if (hex && hex.element && elementCounts[hex.element] !== undefined) {
                    elementCounts[hex.element]++;
                }
            });

            const connections = [
                { p1: 'T1', s1: 2, p2: 'T2', s2: 5 }, { p1: 'M1', s1: 2, p2: 'M2', s2: 5 }, { p1: 'M2', s1: 2, p2: 'M3', s2: 5 }, { p1: 'B1', s1: 2, p2: 'B2', s2: 5 },
                { p1: 'T1', s1: 4, p2: 'M1', s2: 1 }, { p1: 'T1', s1: 3, p2: 'M2', s2: 0 }, { p1: 'T2', s1: 4, p2: 'M2', s2: 1 }, { p1: 'T2', s1: 3, p2: 'M3', s2: 0 },
                { p1: 'M1', s1: 3, p2: 'B1', s2: 0 }, { p1: 'M2', s1: 4, p2: 'B1', s2: 1 }, { p1: 'M2', s1: 3, p2: 'B2', s2: 0 }, { p1: 'M3', s1: 4, p2: 'B2', s2: 1 }
            ];
            connections.forEach(({ p1, s1, p2, s2 }) => {
                const match = calculateMatchScorePair(p[p1], p[p2], s1, s2);
                if (match.score > 0) {
                    score++;
                    if (colorCounts[match.color] !== undefined) {
                        colorCounts[match.color]++;
                    }
                }
            });
            return { score, colorCounts, elementCounts };
        }

        async function findAllBestArrangements(hexagons, centerId, searchMode, onProgress, forcedHexagonIds = new Set()) {
            let bestScore = -1;
            let bestArrangements = [];
            let processedCount = 0;
            const CHUNK_SIZE = 50000;

            const centerHex = centerId ? hexagons.find(h => h.id === centerId) : null;
            
            const slots = centerId 
                ? ['T1', 'T2', 'M1', 'M3', 'B1', 'B2'] 
                : ['T1', 'T2', 'M1', 'M2', 'M3', 'B1', 'B2'];
            
            let candidatePieces = hexagons.slice();
            const totalSlots = slots.length;

            if (candidatePieces.length < totalSlots) {
                const dummyHex = new Hexagon(0, 'empty', 'none', Array(6).fill('none'), 'none');
                const dummiesNeeded = totalSlots - candidatePieces.length;
                for (let i = 0; i < dummiesNeeded; i++) {
                    candidatePieces.push({ ...dummyHex, id: `dummy-${i}`});
                }
            }
            
            const totalForProgress = candidatePieces.length;

            return new Promise(resolve => {
                const stack = [];
                const arrangement = {};
                const usedHexIds = new Set();
                const usedLabels = new Set();
                const placedForcedHexIds = new Set();

                if (centerHex) {
                    arrangement['M2'] = centerHex;
                    usedHexIds.add(centerHex.id);
                    usedLabels.add(centerHex.label);
                    if (forcedHexagonIds.has(centerHex.id)) {
                        placedForcedHexIds.add(centerHex.id);
                    }
                }

                stack.push({ slotIndex: 0, pieceIndex: 0 });

                async function processStack() {
                    let operationsSinceYield = 0;
                    
                    while (stack.length > 0) {
                        if (++operationsSinceYield > CHUNK_SIZE) {
                            const progress = stack.length > 0 ? stack[0].pieceIndex / totalForProgress : 1;
                            onProgress(progress, processedCount, 0);
                            setTimeout(processStack, 0);
                            return;
                        }

                        const currentState = stack[stack.length - 1];
                        const slotIndex = currentState.slotIndex;
                        const pieceIndex = currentState.pieceIndex;

                        if (pieceIndex >= candidatePieces.length) {
                            stack.pop();
                            if (stack.length > 0) {
                                const previousState = stack[stack.length - 1];
                                const previousSlot = slots[previousState.slotIndex];
                                const pieceToRemove = arrangement[previousSlot];
                                
                                if(pieceToRemove) {
                                    usedHexIds.delete(pieceToRemove.id);
                                    usedLabels.delete(pieceToRemove.label);
                                    if (forcedHexagonIds.has(pieceToRemove.id)) {
                                        placedForcedHexIds.delete(pieceToRemove.id);
                                    }
                                    delete arrangement[previousSlot];
                                }
                            }
                            continue;
                        }

                        const piece = candidatePieces[pieceIndex];
                        currentState.pieceIndex++;

                        if (usedHexIds.has(piece.id) || (piece.label !== 'empty' && usedLabels.has(piece.label))) {
                            continue;
                        }
                        
                        if (!forcedHexagonIds.has(piece.id)) {
                            const remainingSlotsAfterThis = slots.length - (slotIndex + 1);
                            const unplacedForcedCount = forcedHexagonIds.size - placedForcedHexIds.size;
                            if (remainingSlotsAfterThis < unplacedForcedCount) {
                                continue; 
                            }
                        }
                        
                        const slot = slots[slotIndex];
                        arrangement[slot] = piece;
                        usedHexIds.add(piece.id);
                        usedLabels.add(piece.label);
                        if (forcedHexagonIds.has(piece.id)) {
                            placedForcedHexIds.add(piece.id);
                        }

                        if (slotIndex === slots.length - 1) {
                            if (placedForcedHexIds.size === forcedHexagonIds.size) {
                                processedCount++;
                                const { score, colorCounts, elementCounts } = calculateArrangementScore(arrangement);

                                if (score > bestScore) {
                                    bestScore = score;
                                    bestArrangements = [{ arrangement: { ...arrangement }, colorCounts, elementCounts }];
                                } else if (score === bestScore && bestScore !== -1) {
                                    bestArrangements.push({ arrangement: { ...arrangement }, colorCounts, elementCounts });
                                }
                            }
                            
                            usedHexIds.delete(piece.id);
                            usedLabels.delete(piece.label);
                            if (forcedHexagonIds.has(piece.id)) {
                                placedForcedHexIds.delete(piece.id);
                            }
                            delete arrangement[slot];

                            if (searchMode === 'stopAt12' && bestScore === 12) {
                                onProgress(1, processedCount, processedCount);
                                resolve({ score: bestScore, arrangements: bestArrangements });
                                return;
                            }
                        } else {
                            stack.push({ slotIndex: slotIndex + 1, pieceIndex: 0 });
                        }
                    }
                    
                    onProgress(1, processedCount, processedCount);
                    resolve({ score: bestScore, arrangements: bestArrangements });
                }

                processStack();
            });
        }

        function applyTieBreaking(bestLayouts, tiebreakMode, colorPriority, elementPriority) {
            if (!bestLayouts || bestLayouts.length === 0) return [];
            
            const sorted = [...bestLayouts].sort((a, b) => {
                if (tiebreakMode === 'rarity') {
                    const rarityA = calculateRarityScore(a.arrangement);
                    const rarityB = calculateRarityScore(b.arrangement);
                    if (rarityB !== rarityA) return rarityB - rarityA;
                } else if (tiebreakMode === 'color') {
                    for (const color of colorPriority) {
                        const diff = b.colorCounts[color] - a.colorCounts[color];
                        if (diff !== 0) return diff;
                    }
                } else if (tiebreakMode === 'element') {
                    for (const element of elementPriority) {
                        const diff = b.elementCounts[element] - a.elementCounts[element];
                        if (diff !== 0) return diff;
                    }
                }
                return 0; // Keep original order if all tie-breakers are equal
            });

            return sorted;
        }

        function preprocessHexagons(hexagons) {
            const sidePatternGroups = new Map();
            hexagons.forEach(hex => {
                const key = hex.sides.join(',');
                if (!sidePatternGroups.has(key)) {
                    sidePatternGroups.set(key, []);
                }
                sidePatternGroups.get(key).push(hex);
            });
            const uniqueHexagons = Array.from(sidePatternGroups.values()).map(group => group[0]);
            return { uniqueHexagons, sidePatternGroups };
        }

        function expandArrangements(baseArrangements, sidePatternGroups) {
            if (!baseArrangements || baseArrangements.length === 0) return [];
            
            const allExpandedArrangements = [];
            const uniqueLayouts = new Set(); // Use a Set to track unique layouts

            baseArrangements.forEach(baseResult => {
                const arrangement = baseResult.arrangement;
                const slots = Object.keys(arrangement);
                const piecesInArrangement = slots.map(slot => arrangement[slot]);
                
                const pieceGroups = piecesInArrangement.map(piece => {
                    if (piece.label === 'empty') {
                        return [piece]; // This is a placeholder, treat as a group of one
                    }
                    const key = piece.sides.join(',');
                    return sidePatternGroups.get(key);
                });

                let combinations = [{}];
                for (let i = 0; i < slots.length; i++) {
                    const slot = slots[i];
                    const group = pieceGroups[i];
                    const newCombinations = [];
                    for (const hex of group) {
                        for (const combo of combinations) {
                            if (hex.label !== 'empty' && Object.values(combo).some(existingHex => existingHex.id === hex.id)) {
                                continue;
                            }
                            const newCombo = { ...combo };
                            newCombo[slot] = hex;
                            newCombinations.push(newCombo);
                        }
                    }
                    combinations = newCombinations;
                }

                combinations.forEach(finalArrangement => {
                    if (Object.keys(finalArrangement).length === slots.length) {
                        // Create a unique key for the layout based on the real pieces and their positions.
                        // Empty slots are treated as identical.
                        const layoutKey = Object.keys(finalArrangement)
                            .sort()
                            .map(slot => {
                                const piece = finalArrangement[slot];
                                return `${slot}:${piece.label === 'empty' ? 'empty' : piece.id}`;
                            })
                            .join(',');

                        if (!uniqueLayouts.has(layoutKey)) {
                            uniqueLayouts.add(layoutKey);
                            allExpandedArrangements.push({
                                arrangement: finalArrangement,
                                colorCounts: baseResult.colorCounts,
                                elementCounts: baseResult.elementCounts
                            });
                        }
                    }
                });
            });
            return allExpandedArrangements;
        }

        // --- Visualisation & UI Logic ---
        const colorMap = { 'red': '#ef4444', 'blue': '#3b82f6', 'purple': '#8b5cf6', 'gray': '#acb0b6', 'yellow': '#eab308', 'none': '#374151' };
        const rarityColor = { 'mythic': '#ef4444', 'legendary': '#eab308', 'epic': '#8b5cf6', 'uncommon': '#22c55e', 'common': '#acb0b6' };

        function getSideMidpoint(size, sideIndex) {
            const angle1 = (Math.PI / 3) * sideIndex - (5 * Math.PI / 6);
            const angle2 = (Math.PI / 3) * (sideIndex + 1) - (5 * Math.PI / 6);
            return { x: (size * Math.cos(angle1) + size * Math.cos(angle2)) / 2, y: (size * Math.sin(angle1) + size * Math.sin(angle2)) / 2 };
        }

        function drawConnections(ctx, arrangement, positions, size) {
            const connections = [
                { p1: 'T1', s1: 2, p2: 'T2', s2: 5 }, { p1: 'M1', s1: 2, p2: 'M2', s2: 5 }, { p1: 'M2', s1: 2, p2: 'M3', s2: 5 }, { p1: 'B1', s1: 2, p2: 'B2', s2: 5 },
                { p1: 'T1', s1: 4, p2: 'M1', s2: 1 }, { p1: 'T1', s1: 3, p2: 'M2', s2: 0 }, { p1: 'T2', s1: 4, p2: 'M2', s2: 1 }, { p1: 'T2', s1: 3, p2: 'M3', s2: 0 },
                { p1: 'M1', s1: 3, p2: 'B1', s2: 0 }, { p1: 'M2', s1: 4, p2: 'B1', s2: 1 }, { p1: 'M2', s1: 3, p2: 'B2', s2: 0 }, { p1: 'M3', s1: 4, p2: 'B2', s2: 1 }
            ];
            connections.forEach(({ p1, s1, p2, s2 }) => {
                const hex1 = arrangement[p1]; const hex2 = arrangement[p2];
                if (hex1 && hex2 && hex1.sides[s1] !== 'none' && hex1.sides[s1] === hex2.sides[s2]) {
                    const pos1 = positions[p1]; const pos2 = positions[p2];
                    const mid1 = getSideMidpoint(size, s1); const mid2 = getSideMidpoint(size, s2);
                    ctx.beginPath();
                    ctx.moveTo(pos1.x + mid1.x, pos1.y + mid1.y);
                    ctx.lineTo(pos2.x + mid2.x, pos2.y + mid2.y);
                    ctx.strokeStyle = colorMap[hex1.sides[s1]];
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
            });
        }

        function drawHexagon(ctx, x, y, size, hexagon) {
            ctx.save();
            ctx.translate(x, y);
            for (let i = 0; i < 6; i++) {
                const angle1 = (Math.PI / 3) * i - (5 * Math.PI / 6);
                const angle2 = (Math.PI / 3) * (i + 1) - (5 * Math.PI / 6);
                const x1 = size * Math.cos(angle1); const y1 = size * Math.sin(angle1);
                const x2 = size * Math.cos(angle2); const y2 = size * Math.sin(angle2);
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.strokeStyle = colorMap[hexagon.sides[i]];
                ctx.lineWidth = 10;
                ctx.stroke();
            }
            ctx.fillStyle = rarityColor[hexagon.rarity];
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.font = 'bold 12px Inter';
            ctx.fillText(hexagon.label, 0, -12);
            ctx.font = '10px Inter';
            ctx.fillText(`(ID: ${hexagon.id})`, 0, 0);
            if (hexagon.element && hexagon.element !== 'none') {
                ctx.fillStyle = elementColors[hexagon.element] || '#ffffff';
                ctx.font = 'bold 10px Inter';
                ctx.fillText(hexagon.element.toUpperCase(), 0, 12);
            }
            ctx.restore();
        }

        function drawArrangement(ctx, arrangement, title) {
            const canvas = ctx.canvas;
            const centerX = canvas.width / 2; const centerY = canvas.height / 2;
            const size = 45; const spacingFactor = 1.15;
            const widthBetween = size * Math.sqrt(3) * spacingFactor;
            const heightBetween = size * 1.5 * spacingFactor;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (!arrangement) {
                ctx.fillStyle = 'white'; ctx.font = '20px Inter'; ctx.textAlign = 'center';
                ctx.fillText(title, centerX, centerY);
                return;
            }
            const positions = {
                M2: { x: centerX, y: centerY }, M1: { x: centerX - widthBetween, y: centerY }, M3: { x: centerX + widthBetween, y: centerY },
                T1: { x: centerX - widthBetween / 2, y: centerY - heightBetween }, T2: { x: centerX + widthBetween / 2, y: centerY - heightBetween },
                B1: { x: centerX - widthBetween / 2, y: centerY + heightBetween }, B2: { x: centerX + widthBetween / 2, y: centerY + heightBetween }
            };
            drawConnections(ctx, arrangement, positions, size);
            for (const key in arrangement) {
                const hexagon = arrangement[key]; const pos = positions[key];
                if (hexagon && pos) { drawHexagon(ctx, pos.x, pos.y, size, hexagon); }
            }
        }

        // --- Main Execution ---
        window.onload = () => {
            const scoreEl = document.getElementById('score');
            const selectEl = document.getElementById('center-piece-select');
            const solveBtn = document.getElementById('solve-button');
            const scoreEl2 = document.getElementById('score2');
            const secondGridContainer = document.getElementById('second-grid-container');
            const progressContainer = document.getElementById('progress-container');
            const progressBar = document.getElementById('progress-bar');
            const progressText = document.getElementById('progress-text');
            const progressContainer2 = document.getElementById('progress-container2');
            const progressBar2 = document.getElementById('progress-bar2');
            const progressText2 = document.getElementById('progress-text2');
            const colorPriorityControls = document.getElementById('color-priority-controls');
            const elementPriorityControls = document.getElementById('element-priority-controls');
            const tiebreakFieldset = document.getElementById('tiebreak-fieldset');
            const resultsSummary1 = document.getElementById('results-summary1');
            const resultsSummary2 = document.getElementById('results-summary2');
            const addShapeBtn = document.getElementById('add-shape-button');
            const addRandomShapeBtn = document.getElementById('add-random-shape-button');
            const hexagonList = document.getElementById('hexagon-list');

            let allBestLayoutsGrid1 = [];
            let allBestLayoutsGrid2 = [];
            let hexagonObjects = [];
            let selectedHexagonIds = new Set();
            let currentPageGrid1 = 1;
            let currentPageGrid2 = 1;
            const LAYOUTS_PER_PAGE = 9;

            function saveHexagonsToStorage() {
                localStorage.setItem('hexagonPool', JSON.stringify(hexagonObjects));
            }

            function loadHexagonsFromStorage() {
                const savedHexagons = localStorage.getItem('hexagonPool');
                if (savedHexagons) {
                    const parsedHexagons = JSON.parse(savedHexagons);
                    return parsedHexagons.map(h => new Hexagon(h.id, h.label, h.rarity, h.sides, h.element));
                }
                return [];
            }

            function updateEstimationText() {
                const estimationEl = document.getElementById('estimation-text1');
                if (!estimationEl) return;

                const selectedValue = document.getElementById('center-piece-select').value;
                const centerId = selectedValue === "any" ? null : parseInt(selectedValue, 10);
                const { uniqueHexagons } = preprocessHexagons(hexagonObjects);

                const tempForcedIds = new Set(selectedHexagonIds);
                if (centerId) {
                    // Don't add the center piece to the count of "selected from list"
                }

                const remainingPool = uniqueHexagons.filter(h => !selectedHexagonIds.has(h.id) && h.id !== centerId);
                const slotsToFill = centerId ? 6 : 7;
                const requiredCount = selectedHexagonIds.size;
                const wildcardSlots = slotsToFill - requiredCount;

                if (wildcardSlots < 0) {
                    estimationEl.textContent = "Error: Too many hexagons selected.";
                    solveBtn.disabled = true;
                    return;
                }
                solveBtn.disabled = false;
                
                const numToChoose = Math.min(wildcardSlots, remainingPool.length);
                const pieceCount = remainingPool.length;
                
                const totalSecondsStr = estimateTime(pieceCount, numToChoose);
                estimationEl.textContent = `Estimated time: ${formatSeconds(totalSecondsStr)}`;
            }

            function setupInitialData() {
                hexagonObjects = loadHexagonsFromStorage();
                selectedHexagonIds.clear();
                populateDropdowns();
                updateHexagonList();
                populateAddShapeForm();
                updateEstimationText();
            }

            function addHexagon() {
                const id = parseInt(document.getElementById('new-hex-id').value, 10);
                const label = document.getElementById('new-hex-label').value;
                const rarity = document.getElementById('new-hex-rarity').value;
                const element = document.getElementById('new-hex-element').value;
                const sides = Array.from(document.querySelectorAll('#new-hex-sides select')).map(s => s.value);

                if (!label || !rarity) {
                    alert('Please fill all fields for the new hexagon.');
                    return;
                }

                const newHex = new Hexagon(id, label, rarity, sides, element);
                hexagonObjects.push(newHex);
                saveHexagonsToStorage();
                populateDropdowns();
                updateHexagonList();
                updateEstimationText();
                
                document.getElementById('new-hex-label').value = '';
                document.getElementById('new-hex-id').value = getNextId();
            }

            function addRandomHexagon() {
                const rarities = Object.keys(rarityValue).filter(r => r !== 'none');
                const colors = Object.keys(colorMap);

                document.getElementById('new-hex-id').value = getNextId();
                document.getElementById('new-hex-label').value = `random_${Math.random().toString(36).substring(2, 7)}`;
                document.getElementById('new-hex-rarity').value = rarities[Math.floor(Math.random() * rarities.length)];
                document.getElementById('new-hex-element').value = elements[Math.floor(Math.random() * elements.length)];
                
                const sideSelectors = document.querySelectorAll('#new-hex-sides select');
                sideSelectors.forEach(selector => {
                    selector.value = colors[Math.floor(Math.random() * colors.length)];
                });

                addHexagon();
            }

            function getNextId() {
                return hexagonObjects.length > 0 ? Math.max(...hexagonObjects.map(h => h.id)) + 1 : 1;
            }

            function populateAddShapeForm() {
                document.getElementById('new-hex-id').value = getNextId();
                const raritySelect = document.getElementById('new-hex-rarity');
                raritySelect.innerHTML = '';
                Object.keys(rarityValue).forEach(rarity => {
                    if (rarity === 'none') return;
                    const option = document.createElement('option');
                    option.value = rarity;
                    option.textContent = rarity.charAt(0).toUpperCase() + rarity.slice(1);
                    raritySelect.appendChild(option);
                });

                const elementSelect = document.getElementById('new-hex-element');
                elementSelect.innerHTML = '';
                elements.forEach(element => {
                    const option = document.createElement('option');
                    option.value = element;
                    option.textContent = element.charAt(0).toUpperCase() + element.slice(1);
                    elementSelect.appendChild(option);
                });

                const sidesContainer = document.getElementById('new-hex-sides');
                sidesContainer.innerHTML = '';
                for (let i = 0; i < 6; i++) {
                    const sideSelect = document.createElement('select');
                    sideSelect.className = 'bg-gray-700 border border-gray-600 rounded-md p-2 text-white';
                    Object.keys(colorMap).forEach(color => {
                        const option = document.createElement('option');
                        option.value = color;
                        option.textContent = color.charAt(0).toUpperCase() + color.slice(1);
                        sideSelect.appendChild(option);
                    });
                    sidesContainer.appendChild(sideSelect);
                }
            }

            function populateDropdowns() {
                const selectedVal = selectEl.value;
                selectEl.innerHTML = '';
                const anyOption = document.createElement('option');
                anyOption.value = "any";
                anyOption.textContent = "Any (Brute Force All)";
                selectEl.appendChild(anyOption);
                hexagonObjects.sort((a, b) => (rarityValue[b.rarity] || 0) - (rarityValue[a.rarity] || 0) || a.label.localeCompare(b.label))
                              .forEach(hex => {
                    const option = document.createElement('option');
                    option.value = hex.id;
                    option.textContent = `${hex.label} (ID: ${hex.id})`;
                    selectEl.appendChild(option);
                });
                selectEl.value = selectedVal;
            }

            function updateHexagonList() {
                hexagonList.innerHTML = '';
                hexagonObjects.forEach(hex => {
                    const hexContainer = document.createElement('div');
                    hexContainer.className = 'relative hex-container';
                    if (selectedHexagonIds.has(hex.id)) {
                        hexContainer.classList.add('selected');
                    }
                    hexContainer.dataset.hexId = hex.id;

                    const canvas = document.createElement('canvas');
                    canvas.width = 140;
                    canvas.height = 140;
                    canvas.className = 'rounded-lg border-2 cursor-pointer';
                    canvas.style.borderColor = rarityColor[hex.rarity] || '#374151';
                    const ctx = canvas.getContext('2d');
                    drawHexagon(ctx, 70, 70, 50, hex);

                    canvas.addEventListener('click', () => {
                        const centerId = selectEl.value === "any" ? null : parseInt(selectEl.value, 10);
                        const limit = centerId ? 6 : 7;

                        if (selectedHexagonIds.has(hex.id)) {
                            selectedHexagonIds.delete(hex.id);
                            hexContainer.classList.remove('selected');
                        } else {
                            if (selectedHexagonIds.size >= limit) {
                                alert(`You can only select up to ${limit} shapes.`);
                                return;
                            }
                            if (hex.id === centerId) {
                                alert("This hexagon is already selected as the center piece.");
                                return;
                            }
                            selectedHexagonIds.add(hex.id);
                            hexContainer.classList.add('selected');
                        }
                        updateEstimationText();
                    });

                    const deleteBtn = document.createElement('button');
                    deleteBtn.textContent = 'X';
                    deleteBtn.className = 'absolute top-0 right-0 bg-red-600 hover:bg-red-700 text-white font-bold w-6 h-6 rounded-full flex items-center justify-center text-xs z-10';
                    deleteBtn.onclick = () => deleteHexagon(hex.id);
                    
                    hexContainer.appendChild(canvas);
                    hexContainer.appendChild(deleteBtn);
                    hexagonList.appendChild(hexContainer);
                });
            }

            function deleteHexagon(id) {
                selectedHexagonIds.delete(id);
                const index = hexagonObjects.findIndex(h => h.id === id);
                if (index > -1) {
                    hexagonObjects.splice(index, 1);
                    saveHexagonsToStorage();
                    updateHexagonList();
                    populateDropdowns();
                    document.getElementById('new-hex-id').value = getNextId();
                    updateEstimationText();
                }
            }

            addShapeBtn.addEventListener('click', addHexagon);
            addRandomShapeBtn.addEventListener('click', addRandomHexagon);
            selectEl.addEventListener('change', () => {
                updateEstimationText();
                const centerId = selectEl.value === "any" ? null : parseInt(selectEl.value, 10);
                const limit = centerId ? 6 : 7;

                if (selectedHexagonIds.has(centerId)) {
                    selectedHexagonIds.delete(centerId);
                    updateHexagonList();
                } else if (selectedHexagonIds.size > limit) {
                    const lastSelectedId = Array.from(selectedHexagonIds).pop();
                    selectedHexagonIds.delete(lastSelectedId);
                    updateHexagonList();
                }

                if (selectedHexagonIds.size > limit) {
                    alert(`Selection limit is now ${limit}. You have ${selectedHexagonIds.size} selected. Please deselect some.`);
                }
            });

            const colors = ['red', 'blue', 'purple', 'gray', 'yellow'];
            for(let i = 1; i <= 3; i++) {
                const prioritySelect = document.createElement('select');
                prioritySelect.id = `color-priority-${i}`;
                prioritySelect.className = "bg-gray-700 border border-gray-600 text-white rounded-md p-2";
                const defaultOption = document.createElement('option');
                defaultOption.value = "none";
                defaultOption.textContent = i === 1 ? '1st' : (i === 2 ? '2nd' : '3rd');
                prioritySelect.appendChild(defaultOption);
                colors.forEach(c => {
                    const opt = document.createElement('option');
                    opt.value = c;
                    opt.textContent = c.charAt(0).toUpperCase() + c.slice(1);
                    prioritySelect.appendChild(opt);
                });
                colorPriorityControls.appendChild(prioritySelect);
            }

            for(let i = 1; i <= 3; i++) {
                const prioritySelect = document.createElement('select');
                prioritySelect.id = `element-priority-${i}`;
                prioritySelect.className = "bg-gray-700 border border-gray-600 text-white rounded-md p-2";
                const defaultOption = document.createElement('option');
                defaultOption.value = "none";
                defaultOption.textContent = i === 1 ? '1st' : (i === 2 ? '2nd' : '3rd');
                prioritySelect.appendChild(defaultOption);
                elements.forEach(e => {
                    const opt = document.createElement('option');
                    opt.value = e;
                    opt.textContent = e.charAt(0).toUpperCase() + e.slice(1);
                    prioritySelect.appendChild(opt);
                });
                elementPriorityControls.appendChild(prioritySelect);
            }

            function updateDisplay(gridNum, bestLayouts, page = 1) {
                if (gridNum === 1) currentPageGrid1 = page;
                if (gridNum === 2) currentPageGrid2 = page;

                const gridLayoutContainer = document.getElementById(`grid${gridNum}-layouts`);
                const paginationContainer = document.getElementById(`grid${gridNum}-pagination`);
                gridLayoutContainer.innerHTML = '';
                paginationContainer.innerHTML = '';

                const tiebreakMode = document.querySelector('input[name="tiebreak-mode"]:checked').value;
                const colorPriority = [];
                const elementPriority = [];

                if (tiebreakMode === 'color') {
                    for(let i = 1; i <= 3; i++) {
                        const val = document.getElementById(`color-priority-${i}`).value;
                        if (val !== 'none') colorPriority.push(val);
                    }
                } else if (tiebreakMode === 'element') {
                    for(let i = 1; i <= 3; i++) {
                        const val = document.getElementById(`element-priority-${i}`).value;
                        if (val !== 'none') elementPriority.push(val);
                    }
                }
                const sortedLayouts = applyTieBreaking(bestLayouts, tiebreakMode, colorPriority, elementPriority);
                
                const totalPages = Math.ceil(sortedLayouts.length / LAYOUTS_PER_PAGE);
                const startIndex = (page - 1) * LAYOUTS_PER_PAGE;
                const endIndex = startIndex + LAYOUTS_PER_PAGE;
                const paginatedLayouts = sortedLayouts.slice(startIndex, endIndex);

                paginatedLayouts.forEach((layout, index) => {
                    const originalIndex = startIndex + index;
                    const container = document.createElement('div');
                    container.className = 'layout-container';
                    container.dataset.layoutIndex = originalIndex;

                    if (gridNum === 1) {
                        container.addEventListener('click', () => {
                            const selected = document.querySelector(`#grid1-layouts .layout-container.selected`);
                            if (selected) selected.classList.remove('selected');
                            container.classList.add('selected');
                            document.getElementById('solve-second-grid-button').disabled = false;
                        });
                    }

                    const title = document.createElement('h3');
                    title.className = 'font-semibold text-lg';
                    title.textContent = `Layout #${originalIndex + 1}`;
                    container.appendChild(title);

                    const canvas = document.createElement('canvas');
                    canvas.width = 400;
                    canvas.height = 400;
                    container.appendChild(canvas);

                    const summaryDiv = document.createElement('div');
                    summaryDiv.className = 'text-xs mt-2';
                    container.appendChild(summaryDiv);

                    gridLayoutContainer.appendChild(container);

                    drawArrangement(canvas.getContext('2d'), layout.arrangement, 'Error');
                    
                    let summaryHTML = '<div>';
                    for (const color in layout.colorCounts) {
                        if (layout.colorCounts[color] > 0) {
                            summaryHTML += `<span class="inline-block mx-2" style="color:${colorMap[color]}">${color.charAt(0).toUpperCase() + color.slice(1)}: ${layout.colorCounts[color]}</span>`;
                        }
                    }
                    summaryHTML += '</div><div class="mt-1">';
                     for (const element in layout.elementCounts) {
                        if (layout.elementCounts[element] > 0) {
                            summaryHTML += `<span class="inline-block mx-2" style="color:${elementColors[element] || '#fff'}">${element.charAt(0).toUpperCase() + element.slice(1)}: ${layout.elementCounts[element]}</span>`;
                        }
                    }
                    summaryHTML += '</div>';
                    summaryDiv.innerHTML = summaryHTML;
                });

                if (totalPages > 1) {
                    const createButton = (text, pageNum, isDisabled = false, isCurrent = false, isEllipsis = false) => {
                        const button = document.createElement('button');
                        button.innerHTML = text;
                        let classes = 'py-2 px-4 font-bold text-white';
                        if (isEllipsis) {
                            classes += ' bg-gray-600 cursor-default';
                        } else if (isCurrent) {
                            classes += ' bg-blue-600';
                        } else if (isDisabled) {
                            classes += ' bg-gray-600 opacity-50 cursor-not-allowed';
                        } else {
                            classes += ' bg-gray-600 hover:bg-gray-700';
                        }
                        button.className = classes;
                        if (!isDisabled && !isCurrent && !isEllipsis) {
                            button.addEventListener('click', () => updateDisplay(gridNum, bestLayouts, pageNum));
                        }
                        return button;
                    };

                    const prevButton = createButton('&larr;', page - 1, page === 1);
                    prevButton.classList.add('rounded-l-md');
                    paginationContainer.appendChild(prevButton);

                    const pagesToShow = [];
                    if (totalPages <= 7) {
                        for (let i = 1; i <= totalPages; i++) {
                            pagesToShow.push(i);
                        }
                    } else {
                        pagesToShow.push(1);
                        if (page > 3) pagesToShow.push('...');
                        if (page > 2) pagesToShow.push(page - 1);
                        if (page !== 1 && page !== totalPages) pagesToShow.push(page);
                        if (page < totalPages - 1) pagesToShow.push(page + 1);
                        if (page < totalPages - 2) pagesToShow.push('...');
                        pagesToShow.push(totalPages);
                    }
                    
                    [...new Set(pagesToShow)].forEach(p => {
                        paginationContainer.appendChild(p === '...' ? createButton('...', 0, false, false, true) : createButton(p, p, false, p === page));
                    });
                    
                    const nextButton = createButton('&rarr;', page + 1, page === totalPages);
                    nextButton.classList.add('rounded-r-md');
                    paginationContainer.appendChild(nextButton);
                }
            }

            tiebreakFieldset.addEventListener('change', () => {
                const tiebreakMode = document.querySelector('input[name="tiebreak-mode"]:checked').value;
                colorPriorityControls.style.display = tiebreakMode === 'color' ? 'flex' : 'none';
                elementPriorityControls.style.display = tiebreakMode === 'element' ? 'flex' : 'none';
                updateDisplay(1, allBestLayoutsGrid1, 1);
                updateDisplay(2, allBestLayoutsGrid2, 1);
            });

            const runSolver = async () => {
                solveBtn.disabled = true;
                tiebreakFieldset.disabled = true;
                document.getElementById('solve-second-grid-button').style.display = 'none';
                secondGridContainer.style.display = 'none';
                document.getElementById('grid1-layouts').innerHTML = '';
                document.getElementById('grid2-layouts').innerHTML = '';
                document.getElementById('grid1-pagination').innerHTML = '';
                document.getElementById('grid2-pagination').innerHTML = '';
                document.getElementById('grid1-title').style.display = 'none';

                scoreEl.textContent = 'Calculating...';
                resultsSummary1.textContent = '';
                progressContainer.style.display = 'block';
                progressBar.style.width = '0%';

                const selectedValue = selectEl.value;
                const centerId = selectedValue === "any" ? null : parseInt(selectedValue, 10);
                const searchMode = document.querySelector('input[name="search-mode"]:checked').value;

                const { uniqueHexagons, sidePatternGroups } = preprocessHexagons(hexagonObjects);
                const estimationText1 = document.getElementById('estimation-text1');
                const forcedIds = new Set(selectedHexagonIds);

                const totalSecondsStr = estimationText1.textContent.replace('Estimated time: ', '');
                
                const { score, arrangements: baseArrangements } = await findAllBestArrangements(uniqueHexagons, centerId, searchMode, (progress, count, total) => {
                    progressBar.style.width = `${progress * 100}%`;
                    const remainingSecondsStr = multiplyBigInt(totalSecondsStr, Math.round((1 - progress) * 100));
                    const finalSecondsStr = divideBigInt(remainingSecondsStr, 100).quotient;
                    estimationText1.textContent = `Time remaining: ${formatSeconds(finalSecondsStr)}`;

                    progressText.textContent = total > 0 
                        ? `Checked ${count.toLocaleString()} / ${total.toLocaleString()} permutations...`
                        : `Evaluated ${count.toLocaleString()} arrangements...`;
                }, forcedIds);
                
                const arrangements = expandArrangements(baseArrangements, sidePatternGroups);
                allBestLayoutsGrid1 = arrangements;
                progressContainer.style.display = 'none';
                progressText.textContent = '';
                scoreEl.textContent = `Maximum Matching Sides: ${score}`;
                resultsSummary1.textContent = `Found ${arrangements.length} layout(s) with this score.`;
                updateEstimationText();
                
                if (arrangements.length > 0) {
                    document.getElementById('grid1-title').style.display = 'block';
                    updateDisplay(1, allBestLayoutsGrid1, 1);
                    document.getElementById('solve-second-grid-button').style.display = 'inline-block';
                    document.getElementById('solve-second-grid-hint').style.display = 'block';
                } else {
                    scoreEl.textContent += ' - No arrangements found.';
                }

                solveBtn.disabled = false;
                tiebreakFieldset.disabled = false;
            };

            const runSecondGridSolver = async () => {
                const selectedLayoutElement = document.querySelector('#grid1-layouts .layout-container.selected');
                if (!selectedLayoutElement) {
                    alert('Please select a layout from the main grid first.');
                    return;
                }

                document.getElementById('solve-second-grid-button').disabled = true;
                secondGridContainer.style.display = 'block';
                scoreEl2.innerHTML = `<h2 class="text-xl font-semibold text-gray-300 mt-4">Second Grid</h2>Calculating...`;
                resultsSummary2.textContent = '';
                progressContainer2.style.display = 'block';
                progressBar2.style.width = '0%';
                document.getElementById('grid2-layouts').innerHTML = '';
                document.getElementById('grid2-pagination').innerHTML = '';

                const selectedLayoutIndex = parseInt(selectedLayoutElement.dataset.layoutIndex, 10);
                const sortedLayouts = applyTieBreaking(allBestLayoutsGrid1, document.querySelector('input[name="tiebreak-mode"]:checked').value);
                const selectedLayout = sortedLayouts[selectedLayoutIndex];
                const usedIds = new Set(Object.values(selectedLayout.arrangement).map(hex => hex.id));
                const remainingHexagons = hexagonObjects.filter(hex => !usedIds.has(hex.id));
                const searchMode = document.querySelector('input[name="search-mode"]:checked').value;
                const estimationText2 = document.getElementById('estimation-text2');
                const numToChooseForSecondGrid = Math.min(remainingHexagons.length, 7);

                if (numToChooseForSecondGrid > 0) {
                    const { uniqueHexagons: uniqueRemaining, sidePatternGroups: remainingGroups } = preprocessHexagons(remainingHexagons);
                    if (uniqueRemaining.length > 0) {
                        const totalSecondsStr2 = estimateTime(uniqueRemaining.length, numToChooseForSecondGrid);
                        estimationText2.textContent = `Estimated time: ${formatSeconds(totalSecondsStr2)}`;

                        const { score: score2, arrangements: baseArrangements2 } = await findAllBestArrangements(uniqueRemaining, null, searchMode, (progress, count, total) => {
                            progressBar2.style.width = `${progress * 100}%`;
                            const remainingSecondsStr = multiplyBigInt(totalSecondsStr2, Math.round((1 - progress) * 100));
                            const finalSecondsStr = divideBigInt(remainingSecondsStr, 100).quotient;
                            estimationText2.textContent = `Time remaining: ${formatSeconds(finalSecondsStr)}`;

                            progressText2.textContent = total > 0
                                ? `Checked ${count.toLocaleString()} / ${total.toLocaleString()} permutations...`
                                : `Evaluated ${count.toLocaleString()} arrangements...`;
                        });

                        const arrangements2 = expandArrangements(baseArrangements2, remainingGroups);
                        allBestLayoutsGrid2 = arrangements2;
                        scoreEl2.innerHTML = `<h2 class="text-xl font-semibold text-gray-300 mt-4">Second Grid</h2>Maximum Matching Sides: ${score2}`;
                        resultsSummary2.textContent = `Found ${arrangements2.length} layout(s) with this score.`;
                        estimationText2.textContent = '';
                        updateDisplay(2, allBestLayoutsGrid2, 1);
                    } else {
                        scoreEl2.innerHTML = `<h2 class="text-xl font-semibold text-gray-300 mt-4">Second Grid</h2>`;
                        resultsSummary2.textContent = 'Not enough unique pieces for a second grid.';
                    }
                } else {
                    scoreEl2.innerHTML = `<h2 class="text-xl font-semibold text-gray-300 mt-4">Second Grid</h2>`;
                    resultsSummary2.textContent = 'Not enough pieces for a second grid.';
                }
                progressContainer2.style.display = 'none';
                progressText2.textContent = '';
                document.getElementById('solve-second-grid-button').disabled = false;
            };

            scoreEl.textContent = 'Select an option and click Solve to begin.';
            document.getElementById('grid1-layouts').innerHTML = '';
            document.getElementById('grid2-layouts').innerHTML = '';

            solveBtn.addEventListener('click', runSolver);
            document.getElementById('solve-second-grid-button').addEventListener('click', runSecondGridSolver);

            setupInitialData();
        };
    </script>
</body>
</html>
