<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-WNH50QZ2NX"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
    
      gtag('config', 'G-WNH50QZ2NX');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hexagon Puzzle Solver</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Pixel Heroes Adventure color palette */
        :root {
            --bg: #0a0a0a;
            --bg-gradient: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
            --panel: #151515;
            --panel-alt: #1a1a1a;
            --panel-border: #2a2a2a;
            --text: #ffffff;
            --muted: #888888;
            --accent-green: #00ff88;
            --accent-blue: #00aaff;
            --accent-purple: #aa77ff;
            --danger: #ff4444;
            --danger-hover: #ff6666;
            --success: #00ff88;
            --outline: #000000;
            --glow-green: rgba(0, 255, 136, 0.5);
            --glow-blue: rgba(0, 170, 255, 0.5);
            --glow-purple: rgba(170, 119, 255, 0.5);
            --shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
            --shadow-lg: 0 8px 32px rgba(0, 0, 0, 0.6);
        }
        
        /* Base styles */
        body {
            font-family: 'Inter', system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            min-height: 100vh;
            background: var(--bg-gradient);
            color: var(--text);
            margin: 0;
            padding: 2rem 0;
            line-height: 1.6;
            overflow-x: hidden;
        }
        
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 50%, rgba(0, 255, 136, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 50%, rgba(170, 119, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 50% 100%, rgba(0, 170, 255, 0.1) 0%, transparent 50%);
            pointer-events: none;
            z-index: 1;
        }
        
        .container {
            position: relative;
            z-index: 2;
            text-align: center;
            background: rgba(21, 21, 21, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid var(--panel-border);
            padding: 2.5rem;
            border-radius: 1.5rem;
            box-shadow: var(--shadow-lg);
            width: 95%;
            max-width: 1400px;
            margin: 0 auto;
        }
        
        canvas {
            background: linear-gradient(145deg, #1a1a1a, #222222);
            border-radius: 1rem;
            margin-top: 1.5rem;
            border: 2px solid var(--panel-border);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.5);
            max-width: 100%;
            height: auto;
        }
        
        h1 {
            font-family: 'Press Start 2P', cursive;
            font-size: 2rem;
            font-weight: 400;
            background: linear-gradient(45deg, var(--accent-green), var(--accent-blue));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px var(--glow-green);
            letter-spacing: 1px;
            margin-bottom: 1.5rem;
        }
        
        h2 {
            font-family: 'Press Start 2P', cursive;
            font-size: 1.2rem;
            color: var(--accent-blue);
            text-shadow: 0 0 20px var(--glow-blue);
            margin-top: 2rem;
            margin-bottom: 1.5rem;
        }
        
        h3 {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.9rem;
            color: var(--accent-purple);
            text-shadow: 0 0 15px var(--glow-purple);
            margin-bottom: 1rem;
        }
        
        p {
            font-size: 0.875rem;
            color: #aaaaaa;
            line-height: 1.6;
            margin-bottom: 1rem;
        }
        
        label {
            font-size: 0.875rem;
            font-weight: 500;
            color: #cccccc;
            line-height: 1.4;
            display: block;
            margin-bottom: 0.5rem;
        }
        
        #score, #score2 {
            font-size: 1.25rem;
            font-weight: 400;
            background: linear-gradient(45deg, var(--accent-green), var(--accent-blue));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-top: 1rem;
            min-height: 2.25rem;
            text-shadow: 0 0 20px var(--glow-green);
        }
        
        #grid1-title {
            color: var(--accent-blue);
            text-shadow: 0 0 20px var(--glow-blue);
            margin-bottom: 2rem !important;
        }
        
        /* Card style sections */
        #data-management,
        #second-grid-container {
            background: rgba(26, 26, 26, 0.8);
            border: 1px solid var(--panel-border);
            border-radius: 1rem;
            padding: 2rem;
            box-shadow: var(--shadow);
            backdrop-filter: blur(5px);
            margin-bottom: 2rem;
        }
        
        #add-shape-form {
            background: rgba(26, 26, 26, 0.8);
            border: 1px solid var(--panel-border);
            border-radius: 1rem;
            padding: 1.5rem;
            box-shadow: var(--shadow);
            backdrop-filter: blur(5px);
            margin-bottom: 1.5rem;
        }
        
        #grid1-layouts .layout-container,
        #grid2-layouts .layout-container {
            background: linear-gradient(145deg, #1a1a1a, #222222);
            border: 1px solid var(--panel-border);
            border-radius: 1rem;
            padding: 1.5rem;
            box-shadow: var(--shadow);
            position: relative;
            overflow: hidden;
            width: 100%;
            max-width: 420px;
            margin: 0 auto;
        }
        
        #grid1-layouts, #grid2-layouts {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 2rem;
            justify-items: center;
            width: 100%;
            margin-top: 2rem;
        }
        
        @media (min-width: 1024px) {
            #grid1-layouts, #grid2-layouts {
                grid-template-columns: repeat(3, 1fr);
            }
        }
        
        #hexagon-list {
            background: rgba(26, 26, 26, 0.6);
            border: 1px solid var(--panel-border);
            border-radius: 1rem;
            padding: 1.5rem;
            backdrop-filter: blur(5px);
        }
        
        /* Form controls */
        select {
            background: linear-gradient(145deg, #222222, #1a1a1a);
            border: 1px solid var(--panel-border);
            color: var(--text);
            padding: 8px 12px;
            border-radius: 0.5rem;
            font-family: 'Inter', system-ui, sans-serif;
            font-size: 0.875rem;
            line-height: 1.4;
            transition: all 0.3s ease;
            max-width: 100%;
        }
        input[type="text"], input[type="number"] {
            background: linear-gradient(145deg, #222222, #1a1a1a);
            border: 1px solid var(--panel-border);
            color: var(--text);
            padding: 8px 12px;
            border-radius: 0.5rem;
            font-family: 'Inter', system-ui, sans-serif;
            font-size: 0.875rem;
            line-height: 1.4;
            transition: all 0.3s ease;
        }
        select:focus, input[type="text"]:focus, input[type="number"]:focus {
            outline: none;
            border-color: var(--accent-green);
            box-shadow: 0 0 15px var(--glow-green);
        }
        select option {
            background: var(--panel);
            font-size: 0.875rem;
            padding: 4px 8px;
        }
        input[type="radio"], input[type="checkbox"] {
            accent-color: var(--accent-green);
        }
        
        /* Buttons */
        .container button {
            background: linear-gradient(145deg, var(--accent-green), #00cc66);
            border: none;
            color: var(--bg);
            font-family: 'Inter', system-ui, sans-serif;
            font-weight: 600;
            font-size: 0.875rem;
            padding: 12px 24px;
            border-radius: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0, 255, 136, 0.3);
            line-height: 1.2;
        }
        .container button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.3s, height 0.3s;
        }
        .container button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 255, 136, 0.5);
        }
        .container button:hover:not(:disabled)::before {
            width: 300px;
            height: 300px;
        }
        .container button:active:not(:disabled) {
            transform: translateY(0);
        }
        .container button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: linear-gradient(145deg, #444444, #333333);
        }
        
        /* Special button variants */
        button#solve-button, button#add-shape-button {
            background: linear-gradient(145deg, var(--accent-blue), #0088cc);
            box-shadow: 0 4px 15px rgba(0, 170, 255, 0.3);
        }
        button#solve-button:hover:not(:disabled), button#add-shape-button:hover:not(:disabled) {
            box-shadow: 0 6px 20px rgba(0, 170, 255, 0.5);
        }
        
        button#solve-second-grid-button {
            background: linear-gradient(145deg, var(--accent-purple), #8844ff);
            box-shadow: 0 4px 15px rgba(170, 119, 255, 0.3);
        }
        button#solve-second-grid-button:hover:not(:disabled) {
            box-shadow: 0 6px 20px rgba(170, 119, 255, 0.5);
        }
        
        /* Delete button */
        .hex-container > button {
            background: var(--danger) !important;
            border: 1px solid var(--danger-hover) !important;
            color: #fff !important;
            width: 30px !important;
            height: 30px !important;
            font-size: 0.8rem !important;
            padding: 0 !important;
            box-shadow: 0 2px 8px rgba(255, 68, 68, 0.3) !important;
        }
        .hex-container > button:hover {
            background: var(--danger-hover) !important;
            box-shadow: 0 4px 12px rgba(255, 68, 68, 0.5) !important;
        }
        
        /* Layout containers */
        .layout-container {
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }
        .layout-container::before {
            content: '';
            position: absolute;
            inset: -1px;
            border-radius: 1rem;
            padding: 1px;
            background: linear-gradient(45deg, transparent, var(--accent-purple), transparent);
            mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            mask-composite: exclude;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .layout-container:hover {
            transform: translateY(-4px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }
        .layout-container:hover::before {
            opacity: 1;
        }
        .layout-container.selected {
            transform: scale(1.02);
            box-shadow: 0 0 30px var(--glow-green);
            border-color: var(--accent-green);
        }
        
        /* Hexagon tiles */
        #hexagon-list .hex-container {
            position: relative;
            flex: 0 0 auto;
        }
        #hexagon-list .hex-container canvas {
            border: 2px solid var(--panel-border);
            background: linear-gradient(145deg, #1a1a1a, #222222);
            transition: all 0.3s ease;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }
        #hexagon-list .hex-container:hover canvas {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
        }
        #hexagon-list .hex-container.selected canvas {
            border-color: var(--accent-green);
            box-shadow: 0 0 25px var(--glow-green);
            transform: scale(1.05) translateY(-3px);
        }
        
        /* Progress bars */
        #progress-container, #progress-container2 {
            background: rgba(255, 255, 255, 0.1) !important;
            border: 1px solid var(--panel-border);
            border-radius: 1rem;
            overflow: hidden;
            height: 12px !important;
        }
        #progress-bar, #progress-bar2 {
            background: linear-gradient(90deg, var(--accent-green), var(--accent-blue)) !important;
            height: 100% !important;
            transition: width 0.3s ease-out;
            position: relative;
            overflow: hidden;
        }
        #progress-bar::after, #progress-bar2::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: shimmer 2s infinite;
        }
        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        /* Text styles */
        .control-group {
            margin-bottom: 1.5rem;
        }
        .results-summary {
            color: #aaaaaa;
            font-style: italic;
            margin-top: 0.5rem;
            font-size: 0.875rem;
        }
        #progress-text, #progress-text2,
        #estimation-text1, #estimation-text2 {
            color: #aaaaaa;
            font-size: 0.875rem;
        }
        .text-yellow-400 {
            color: var(--accent-green) !important;
        }
        
        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }
        ::-webkit-scrollbar-track {
            background: var(--panel);
        }
        ::-webkit-scrollbar-thumb {
            background: var(--accent-purple);
            border-radius: 5px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent-blue);
        }
        
        /* Pagination buttons */
        #grid1-pagination, #grid2-pagination {
            margin-top: 2rem;
        }
        #grid1-pagination button, #grid2-pagination button {
            background: linear-gradient(145deg, var(--accent-purple), #8844ff) !important;
            border: 1px solid var(--accent-purple) !important;
            border-radius: 0.5rem !important;
            font-size: 0.75rem !important;
            padding: 8px 12px !important;
            margin: 0 3px;
            line-height: 1.2 !important;
            color: white !important;
            font-weight: 600 !important;
        }
        #grid1-pagination button:hover:not(:disabled), #grid2-pagination button:hover:not(:disabled) {
            background: linear-gradient(145deg, var(--accent-blue), #0088cc) !important;
            border-color: var(--accent-blue) !important;
            box-shadow: 0 4px 12px rgba(0, 170, 255, 0.5) !important;
            transform: translateY(-1px);
        }
        #grid1-pagination button.current-page {
            background: linear-gradient(145deg, var(--accent-green), #00cc66) !important;
            border-color: var(--accent-green) !important;
            box-shadow: 0 4px 12px rgba(0, 255, 136, 0.4) !important;
        }
        #grid1-pagination button:disabled {
            opacity: 0.3 !important;
        }
        
        /* Text utility classes */
        .text-sm {
            font-size: 0.875rem !important;
            line-height: 1.4 !important;
        }
        .text-xs {
            font-size: 0.75rem !important;
            line-height: 1.3 !important;
        }
        .text-lg {
            font-size: 1.125rem !important;
        }
        .text-xl {
            font-size: 1.25rem !important;
        }
        
        /* Radio button and checkbox styling improvements */
        input[type="radio"], input[type="checkbox"] {
            margin-right: 0.5rem;
            transform: scale(1.2);
        }
        
        /* Improve spacing for form elements */
        .control-group label {
            margin-bottom: 0.25rem;
        }
        
        .control-group .flex {
            gap: 1rem;
            align-items: center;
        }
        
        /* Progress text styling */
        #progress-text, #progress-text2 {
            font-size: 0.875rem;
            line-height: 1.5;
        }
        #estimation-text1, #estimation-text2 {
            font-size: 0.875rem;
            line-height: 1.5;
            font-weight: 500;
        }
        
        /* Motion preferences */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
            .container button:hover:not(:disabled) {
                transform: none;
            }
            .layout-container:hover {
                transform: none;
            }
            #hexagon-list .hex-container:hover canvas {
                transform: none;
            }
        }
        
        /* Toast notification styles */
        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 9999;
            pointer-events: none;
        }
        .toast {
            background: linear-gradient(145deg, #2a2a2a, #1a1a1a);
            border: 1px solid var(--panel-border);
            border-radius: 0.5rem;
            padding: 12px 20px;
            margin-bottom: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            opacity: 0;
            transform: translateX(100%);
            transition: all 0.3s ease;
            pointer-events: auto;
            font-size: 0.875rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .toast.show {
            opacity: 1;
            transform: translateX(0);
        }
        .toast.warning {
            border-color: var(--danger);
            box-shadow: 0 4px 12px rgba(255, 68, 68, 0.3);
        }
        .toast.success {
            border-color: var(--accent-green);
            box-shadow: 0 4px 12px rgba(0, 255, 136, 0.3);
        }
        
        /* Shape pool styles */
        .shape-pool-item {
            position: relative;
            cursor: pointer;
            transition: transform 0.2s;
        }
        .shape-pool-item:hover {
            transform: scale(1.05);
        }
        .shape-pool-item.selected {
            outline: 3px solid var(--accent-green);
            outline-offset: 2px;
        }
        
        /* Custom scrollbar for shape pools */
        #available-shapes::-webkit-scrollbar,
        #selected-shapes::-webkit-scrollbar {
            width: 8px;
        }
        #available-shapes::-webkit-scrollbar-track,
        #selected-shapes::-webkit-scrollbar-track {
            background: rgba(42, 42, 42, 0.5);
            border-radius: 4px;
        }
        #available-shapes::-webkit-scrollbar-thumb,
        #selected-shapes::-webkit-scrollbar-thumb {
            background: var(--accent-purple);
            border-radius: 4px;
        }
        #available-shapes::-webkit-scrollbar-thumb:hover,
        #selected-shapes::-webkit-scrollbar-thumb:hover {
            background: var(--accent-blue);
        }
        
        /* Size slider styling */
        #shape-size-slider {
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            background: linear-gradient(145deg, #222222, #1a1a1a);
            border: 1px solid var(--panel-border);
            border-radius: 3px;
            outline: none;
        }
        #shape-size-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: linear-gradient(145deg, var(--accent-green), #00cc66);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            transition: all 0.2s;
        }
        #shape-size-slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 0 10px var(--glow-green);
        }
        #shape-size-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: linear-gradient(145deg, var(--accent-green), #00cc66);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            transition: all 0.2s;
            border: none;
        }
        #shape-size-slider::-moz-range-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 0 10px var(--glow-green);
        }
        
        /* Hex container selection overlay */
        #hexagon-list .hex-container::after {
            content: '✓';
            position: absolute;
            top: 5px;
            left: 5px;
            background: var(--accent-green);
            color: var(--bg);
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: none;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 14px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        #hexagon-list .hex-container.selected::after {
            display: flex;
        }
    </style>
</head>
<body>
    <!-- Toast notification container -->
    <div id="toast-container" class="toast-container" aria-live="polite" aria-atomic="true"></div>

    <div class="container">
        <h1 class="text-xl font-semibold">Pixel Heroes Adventure - Toyz Optimizer</h1>
        <p>Maximize your hero's stats by finding the optimal Toyz arrangement in the 2-3-2 grid layout.</p>
        <p class="text-xs text-gray-500 mt-1">Better Toyz arrangements = Higher stat boosts for your Pixel Heroes!</p>
        

        <div id="data-management" class="mt-8">
            
            <!-- Add Shape Form -->
            <div id="add-shape-form" class="my-4 p-4 border border-gray-600 rounded-lg">
                <h3 class="text-lg font-semibold text-gray-300 mb-2">Add a New Toyz</h3>
                <p class="text-sm text-gray-500 mt-1 mb-4">Add your Toyz pieces to the collection. Each Toyz has different rarities and elements that affect your hero's power!</p>
                <div class="grid grid-cols-1 md:grid-cols-4 gap-4">
                    <div>
                        <label for="new-hex-id" class="block text-sm font-medium text-gray-400">ID</label>
                        <input type="number" id="new-hex-id" class="mt-1 block w-full bg-gray-800 border border-gray-600 rounded-md p-2 text-white" disabled/>
                    </div>
                    <div>
                        <label for="new-hex-label" class="block text-sm font-medium text-gray-400">Label</label>
                        <input type="text" id="new-hex-label" class="mt-1 block w-full bg-gray-700 border border-gray-600 rounded-md p-2 text-white"/>
                    </div>
                    <div>
                        <label for="new-hex-rarity" class="block text-sm font-medium text-gray-400">Rarity</label>
                        <select id="new-hex-rarity" class="mt-1 block w-full bg-gray-700 border border-gray-600 rounded-md p-2 text-white"></select>
                    </div>
                    <div>
                        <label for="new-hex-element" class="block text-sm font-medium text-gray-400">Element</label>
                        <select id="new-hex-element" class="mt-1 block w-full bg-gray-700 border border-gray-600 rounded-md p-2 text-white"></select>
                    </div>
                </div>
                <div class="mt-4">
                    <label class="block text-sm font-medium text-gray-400">Sides (Top-Left, Top-Right, Right, Bottom-Right, Bottom-Left, Left)</label>
                    <div id="new-hex-sides" class="grid grid-cols-6 gap-2 mt-1"></div>
                </div>
                <button id="add-shape-button" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md mt-4">Add Toyz</button>
                <button id="add-random-shape-button" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md mt-4">Add Random Toyz</button>
            </div>

            <h3 class="text-lg font-semibold text-gray-300">Toyz Collection</h3>
            <p class="text-sm text-gray-500 mt-1 mb-3">Manage your Toyz inventory! Move Toyz to the selected pool to optimize their arrangement. The solver will maximize matching sides for the best stat multipliers.</p>
            
            <!-- Size slider control -->
            <div class="flex items-center gap-4 mt-4 mb-4">
                <label for="shape-size-slider" class="text-sm text-gray-400">Shape Size:</label>
                <input type="range" id="shape-size-slider" min="80" max="200" value="140" class="flex-1 max-w-xs" />
                <span id="shape-size-value" class="text-sm text-gray-400 min-w-[3rem]">140px</span>
            </div>
            
            <div class="flex flex-col lg:flex-row gap-6">
                <!-- Available Shapes Pool -->
                <div class="flex-1">
                    <div class="flex items-center justify-between mb-2">
                        <h4 class="text-md font-semibold text-gray-400">Available Toyz</h4>
                        <span id="available-counter" class="text-sm text-gray-500">Count: 0</span>
                    </div>
                    <div id="available-shapes" class="flex flex-wrap justify-center gap-4 p-4 rounded-lg border border-gray-600 bg-gray-800/30 min-h-[200px] max-h-[400px] overflow-y-auto overflow-x-hidden"></div>
                </div>
                
                <!-- Transfer Controls -->
                <div class="flex flex-col justify-center items-center gap-4 my-auto">
                    <button id="move-to-selected" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-md flex items-center gap-2 w-32" title="Move selected Toyz to Selected Pool">
                        <span class="text-lg">→</span>
                        <span class="hidden lg:inline">Move</span>
                    </button>
                    <button id="move-all-to-selected" class="bg-green-700 hover:bg-green-800 text-white font-bold py-2 px-4 rounded-md flex items-center gap-2 w-32" title="Move ALL Toyz to Selected Pool">
                        <span class="text-lg">⇒</span>
                        <span class="hidden lg:inline">Move All</span>
                    </button>
                    <button id="move-all-to-available" class="bg-blue-700 hover:bg-blue-800 text-white font-bold py-2 px-4 rounded-md flex items-center gap-2 w-32" title="Move ALL Toyz to Available Pool">
                        <span class="text-lg">⇐</span>
                        <span class="hidden lg:inline">Return All</span>
                    </button>
                    <button id="move-to-available" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md flex items-center gap-2 w-32" title="Move selected Toyz to Available Pool">
                        <span class="text-lg">←</span>
                        <span class="hidden lg:inline">Return</span>
                    </button>
                </div>
                
                <!-- Selected Shapes Pool -->
                <div class="flex-1">
                    <div class="flex items-center justify-between mb-2">
                        <h4 class="text-md font-semibold text-gray-400">Selected Toyz for Battle</h4>
                        <span id="selected-counter" class="text-sm text-gray-500">Count: 0</span>
                    </div>
                    <div id="selected-shapes" class="flex flex-wrap justify-center gap-4 p-4 rounded-lg border border-gray-600 bg-gray-800/30 min-h-[200px] max-h-[400px] overflow-y-auto overflow-x-hidden"></div>
                </div>
            </div>
        </div>
        
        <div class="my-4 flex flex-col items-center justify-center gap-4">
            <div class="control-group">
                <label for="center-piece-select" class="mr-2 text-gray-400">Center Piece (M2):</label>
                <select id="center-piece-select" class="bg-gray-700 border border-gray-600 text-white rounded-md p-2 focus:ring-2 focus:ring-blue-500 focus:outline-none">
                </select>
                <p class="text-sm text-gray-500 mt-1">Lock your strongest Toyz in the center (M2) position for strategic placement!</p>
            </div>
            <div class="control-group flex flex-wrap items-center gap-4">
                <span class="text-gray-400 text-sm">Search Mode:</span>
                <label class="flex items-center text-sm"><input type="radio" name="search-mode" value="bestScore" checked class="form-radio h-4 w-4 text-blue-600 bg-gray-700 border-gray-600 focus:ring-blue-500"> <span class="ml-2">Find Best Score</span></label>
                <label class="flex items-center text-sm"><input type="radio" name="search-mode" value="stopAt12" class="form-radio h-4 w-4 text-blue-600 bg-gray-700 border-gray-600 focus:ring-blue-500"> <span class="ml-2">Stop at 12</span></label>
            </div>
            <fieldset id="tiebreak-fieldset" class="control-group" disabled>
                <span class="text-gray-400 text-sm">Tie-Breaking Strategy:</span>
                <p class="text-sm text-gray-500 mt-1 mb-3">When multiple layouts share the same top score, this determines how they are sorted. You can prioritize by the total rarity of pieces, the number of matches of a specific color, or the number of pieces of a specific element.</p>
                <div class="flex flex-wrap items-center justify-center gap-4 mt-2">
                    <label class="flex items-center text-sm"><input type="radio" name="tiebreak-mode" value="rarity" checked class="form-radio h-4 w-4 text-blue-600 bg-gray-700 border-gray-600 focus:ring-blue-500"> <span class="ml-2">Rarity</span></label>
                    <label class="flex items-center text-sm"><input type="radio" name="tiebreak-mode" value="color" class="form-radio h-4 w-4 text-blue-600 bg-gray-700 border-gray-600 focus:ring-blue-500"> <span class="ml-2">Color Priority</span></label>
                    <label class="flex items-center text-sm"><input type="radio" name="tiebreak-mode" value="element" class="form-radio h-4 w-4 text-blue-600 bg-gray-700 border-gray-600 focus:ring-blue-500"> <span class="ml-2">Element Priority</span></label>
                </div>
                <div id="color-priority-controls" class="control-group flex-wrap items-center justify-center gap-2 mt-2" style="display: none;">
                    <!-- Color priority dropdowns will be added here -->
                </div>
                <div id="element-priority-controls" class="control-group flex-wrap items-center justify-center gap-2 mt-2" style="display: none;">
                    <!-- Element priority dropdowns will be added here -->
                </div>
            </fieldset>
            <button id="solve-button" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md">Optimize Toyz Layout</button>
            <p id="solve-button-hint" class="text-sm text-gray-500 mt-1">Find the best Toyz arrangement to maximize your hero's stat boosts!</p>
        </div>

        <div id="progress-container" class="w-full bg-gray-600 rounded-full h-2.5 mt-4" style="display: none;">
            <div id="progress-bar" class="bg-blue-500 h-2.5 rounded-full" style="width: 0%"></div>
        </div>
        <div id="progress-text" class="text-sm text-gray-400 mt-1" aria-live="polite"></div>
        <div id="estimation-text1" class="text-sm text-gray-400 mt-1" aria-live="polite"></div>
        <div id="solve-error" class="text-sm text-red-400 mt-1" style="display: none;" aria-live="assertive"></div>
        <p class="text-xs text-yellow-400 mt-1">Note: The time estimation may be inaccurate for very large numbers of hexagons.</p>
        
        <div id="score"></div>
        <div id="results-summary1" class="results-summary"></div>
        <h2 id="grid1-title" class="text-xl font-semibold text-gray-300 mt-4" style="display: none;">Optimal Toyz Arrangements</h2>
        <div id="grid1-layouts">
        </div>
        <div id="grid1-pagination" class="flex justify-center items-center mt-4"></div>
        <div class="my-4">
            <button id="solve-second-grid-button" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-md" style="display: none;" disabled>Solve Second Grid</button>
            <p id="solve-second-grid-hint" class="text-sm text-gray-500 mt-1" style="display: none;">After finding the first grid, select one of the resulting layouts above, then click here to find the best arrangement for a second grid using the remaining pieces.</p>
        </div>

        <div id="second-grid-container" class="mt-8" style="display: none;">
             <div id="progress-container2" class="w-full bg-gray-600 rounded-full h-2.5 mt-4" style="display: none;">
                <div id="progress-bar2" class="bg-blue-500 h-2.5 rounded-full" style="width: 0%"></div>
            </div>
            <div id="progress-text2" class="text-sm text-gray-400 mt-1"></div>
            <div id="estimation-text2" class="text-sm text-gray-400 mt-1"></div>
             <div id="score2"></div>
             <div id="results-summary2" class="results-summary"></div>
             <div id="grid2-layouts">
            </div>
            <div id="grid2-pagination" class="flex justify-center items-center mt-4"></div>
        </div>
    </div>

    <script>
        // --- Core Puzzle Logic ---
        const elements = ['normal', 'fire', 'water', 'wind', 'plant', 'mud', 'dark', 'light', 'ice', 'electric', 'poison'];
        const elementColors = {
            normal: '#A8A77A', fire: '#EE8130', water: '#6390F0', electric: '#F7D02C', plant: '#7AC74C',
            ice: '#96D9D6', mud: '#E2BF65', dark: '#705746', light: '#F85888', wind: '#A98FF3', poison: '#A040A0'
        };


        class Hexagon {
            constructor(id, label, rarity, sides, element) {
                this.id = id;
                this.label = label;
                this.rarity = rarity;
                this.sides = sides;
                this.element = element;
            }
        }

        // --- BigInt Arithmetic for Time Estimation ---
        function multiplyBigInt(num1, num2) {
            let a = num1.split('').reverse();
            let b = String(num2).split('').reverse();
            let result = [];

            for (let i = 0; i < a.length; i++) {
                for (let j = 0; j < b.length; j++) {
                    let index = i + j;
                    let product = a[i] * b[j];
                    result[index] = result[index] ? result[index] + product : product;
                }
            }

            for (let i = 0; i < result.length; i++) {
                if (result[i] >= 10) {
                    let carry = Math.floor(result[i] / 10);
                    result[i] %= 10;
                    result[i+1] = result[i+1] ? result[i+1] + carry : carry;
                }
            }
            return result.reverse().join('');
        }

        function divideBigInt(dividendStr, divisor) {
            let quotient = '';
            let remainder = 0;
            for (let i = 0; i < dividendStr.length; i++) {
                remainder = remainder * 10 + parseInt(dividendStr[i]);
                if (remainder >= divisor) {
                    quotient += Math.floor(remainder / divisor);
                    remainder %= divisor;
                } else {
                    if (quotient !== '') quotient += '0';
                }
            }
            return { quotient: quotient === '' ? '0' : quotient, remainder };
        }

        function formatSeconds(secondsStr) {
            if (secondsStr === '0') return 'less than a second';

            const divBy60 = divideBigInt(secondsStr, 60);
            const seconds = divBy60.remainder;
            const totalMinutesStr = divBy60.quotient;
            if (totalMinutesStr === '0') return `${seconds}s`;

            const divMinutesBy60 = divideBigInt(totalMinutesStr, 60);
            const minutes = divMinutesBy60.remainder;
            const totalHoursStr = divMinutesBy60.quotient;
            if (totalHoursStr === '0') return `${minutes}m ${seconds}s`;

            const divHoursBy24 = divideBigInt(totalHoursStr, 24);
            const hours = divHoursBy24.remainder;
            const days = divHoursBy24.quotient;
            if (days === '0') return `${hours}h ${minutes}m ${seconds}s`;
            
            return `${days}d ${hours}h ${minutes}m`;
        }

        function estimateTime(pieceCount, numToChoose) {
            if (pieceCount < numToChoose) return '0';
            let permutations = '1';
            for (let i = 0; i < numToChoose; i++) {
                permutations = multiplyBigInt(permutations, pieceCount - i);
            }
            const OPS_PER_SECOND = 500_000;
            return divideBigInt(permutations, OPS_PER_SECOND).quotient;
        }
        
        const rarityValue = { 'mythic': 5, 'legendary': 4, 'epic': 3, 'uncommon': 2, 'common': 1, 'none': 0 };

        function calculateRarityScore(arrangement) {
            return Object.values(arrangement).reduce((sum, hex) => sum + (rarityValue[hex.rarity] || 0), 0);
        }

        function calculateMatchScorePair(hex1, hex2, sideIndex1, sideIndex2) {
            if (!hex1 || !hex2) return { score: 0, color: null };
            const color1 = hex1.sides[sideIndex1];
            const color2 = hex2.sides[sideIndex2];
            if (color1 !== 'none' && color1 === color2) {
                return { score: 1, color: color1 };
            }
            return { score: 0, color: null };
        }

        function calculateArrangementScore(p) {
            let score = 0;
            const colorCounts = { red: 0, blue: 0, purple: 0, gray: 0, yellow: 0 };
            const elementCounts = Object.fromEntries(elements.map(e => [e, 0]));

            Object.values(p).forEach(hex => {
                if (hex && hex.element && elementCounts[hex.element] !== undefined) {
                    elementCounts[hex.element]++;
                }
            });

            const connections = [
                { p1: 'T1', s1: 2, p2: 'T2', s2: 5 }, { p1: 'M1', s1: 2, p2: 'M2', s2: 5 }, { p1: 'M2', s1: 2, p2: 'M3', s2: 5 }, { p1: 'B1', s1: 2, p2: 'B2', s2: 5 },
                { p1: 'T1', s1: 4, p2: 'M1', s2: 1 }, { p1: 'T1', s1: 3, p2: 'M2', s2: 0 }, { p1: 'T2', s1: 4, p2: 'M2', s2: 1 }, { p1: 'T2', s1: 3, p2: 'M3', s2: 0 },
                { p1: 'M1', s1: 3, p2: 'B1', s2: 0 }, { p1: 'M2', s1: 4, p2: 'B1', s2: 1 }, { p1: 'M2', s1: 3, p2: 'B2', s2: 0 }, { p1: 'M3', s1: 4, p2: 'B2', s2: 1 }
            ];
            connections.forEach(({ p1, s1, p2, s2 }) => {
                const match = calculateMatchScorePair(p[p1], p[p2], s1, s2);
                if (match.score > 0) {
                    score++;
                    if (colorCounts[match.color] !== undefined) {
                        colorCounts[match.color]++;
                    }
                }
            });
            return { score, colorCounts, elementCounts };
        }

        async function findAllBestArrangements(hexagons, centerId, searchMode, onProgress, forcedHexagonIds = new Set()) {
            let bestScore = -1;
            let bestArrangements = [];
            let processedCount = 0;
            const CHUNK_SIZE = 50000;

            const centerHex = centerId ? hexagons.find(h => h.id === centerId) : null;
            
            const slots = centerId 
                ? ['T1', 'T2', 'M1', 'M3', 'B1', 'B2'] 
                : ['T1', 'T2', 'M1', 'M2', 'M3', 'B1', 'B2'];
            
            let candidatePieces = hexagons.slice();
            const totalSlots = slots.length;

            if (candidatePieces.length < totalSlots) {
                const dummyHex = new Hexagon(0, 'empty', 'none', Array(6).fill('none'), 'none');
                const dummiesNeeded = totalSlots - candidatePieces.length;
                for (let i = 0; i < dummiesNeeded; i++) {
                    candidatePieces.push({ ...dummyHex, id: `dummy-${i}`});
                }
            }
            
            const totalForProgress = candidatePieces.length;

            return new Promise(resolve => {
                const stack = [];
                const arrangement = {};
                const usedHexIds = new Set();
                const usedLabels = new Set();
                const placedForcedHexIds = new Set();

                if (centerHex) {
                    arrangement['M2'] = centerHex;
                    usedHexIds.add(centerHex.id);
                    usedLabels.add(centerHex.label);
                    if (forcedHexagonIds.has(centerHex.id)) {
                        placedForcedHexIds.add(centerHex.id);
                    }
                }

                stack.push({ slotIndex: 0, pieceIndex: 0 });

                async function processStack() {
                    let operationsSinceYield = 0;
                    
                    while (stack.length > 0) {
                        if (++operationsSinceYield > CHUNK_SIZE) {
                            const progress = stack.length > 0 ? stack[0].pieceIndex / totalForProgress : 1;
                            onProgress(progress, processedCount, 0);
                            setTimeout(processStack, 0);
                            return;
                        }

                        const currentState = stack[stack.length - 1];
                        const slotIndex = currentState.slotIndex;
                        const pieceIndex = currentState.pieceIndex;

                        if (pieceIndex >= candidatePieces.length) {
                            stack.pop();
                            if (stack.length > 0) {
                                const previousState = stack[stack.length - 1];
                                const previousSlot = slots[previousState.slotIndex];
                                const pieceToRemove = arrangement[previousSlot];
                                
                                if(pieceToRemove) {
                                    usedHexIds.delete(pieceToRemove.id);
                                    usedLabels.delete(pieceToRemove.label);
                                    if (forcedHexagonIds.has(pieceToRemove.id)) {
                                        placedForcedHexIds.delete(pieceToRemove.id);
                                    }
                                    delete arrangement[previousSlot];
                                }
                            }
                            continue;
                        }

                        const piece = candidatePieces[pieceIndex];
                        currentState.pieceIndex++;

                        if (usedHexIds.has(piece.id) || (piece.label !== 'empty' && usedLabels.has(piece.label))) {
                            continue;
                        }
                        
                        if (!forcedHexagonIds.has(piece.id)) {
                            const remainingSlotsAfterThis = slots.length - (slotIndex + 1);
                            const unplacedForcedCount = forcedHexagonIds.size - placedForcedHexIds.size;
                            if (remainingSlotsAfterThis < unplacedForcedCount) {
                                continue; 
                            }
                        }
                        
                        const slot = slots[slotIndex];
                        arrangement[slot] = piece;
                        usedHexIds.add(piece.id);
                        usedLabels.add(piece.label);
                        if (forcedHexagonIds.has(piece.id)) {
                            placedForcedHexIds.add(piece.id);
                        }

                        if (slotIndex === slots.length - 1) {
                            if (placedForcedHexIds.size === forcedHexagonIds.size) {
                                processedCount++;
                                const { score, colorCounts, elementCounts } = calculateArrangementScore(arrangement);

                                if (score > bestScore) {
                                    bestScore = score;
                                    bestArrangements = [{ arrangement: { ...arrangement }, colorCounts, elementCounts }];
                                } else if (score === bestScore && bestScore !== -1) {
                                    bestArrangements.push({ arrangement: { ...arrangement }, colorCounts, elementCounts });
                                }
                            }
                            
                            usedHexIds.delete(piece.id);
                            usedLabels.delete(piece.label);
                            if (forcedHexagonIds.has(piece.id)) {
                                placedForcedHexIds.delete(piece.id);
                            }
                            delete arrangement[slot];

                            if (searchMode === 'stopAt12' && bestScore === 12) {
                                onProgress(1, processedCount, processedCount);
                                resolve({ score: bestScore, arrangements: bestArrangements });
                                return;
                            }
                        } else {
                            stack.push({ slotIndex: slotIndex + 1, pieceIndex: 0 });
                        }
                    }
                    
                    onProgress(1, processedCount, processedCount);
                    resolve({ score: bestScore, arrangements: bestArrangements });
                }

                processStack();
            });
        }

        function applyTieBreaking(bestLayouts, tiebreakMode, colorPriority, elementPriority) {
            if (!bestLayouts || bestLayouts.length === 0) return [];
            
            const sorted = [...bestLayouts].sort((a, b) => {
                if (tiebreakMode === 'rarity') {
                    const rarityA = calculateRarityScore(a.arrangement);
                    const rarityB = calculateRarityScore(b.arrangement);
                    if (rarityB !== rarityA) return rarityB - rarityA;
                } else if (tiebreakMode === 'color') {
                    for (const color of colorPriority) {
                        const diff = b.colorCounts[color] - a.colorCounts[color];
                        if (diff !== 0) return diff;
                    }
                } else if (tiebreakMode === 'element') {
                    for (const element of elementPriority) {
                        const diff = b.elementCounts[element] - a.elementCounts[element];
                        if (diff !== 0) return diff;
                    }
                }
                return 0; // Keep original order if all tie-breakers are equal
            });

            return sorted;
        }

        function preprocessHexagons(hexagons) {
            const sidePatternGroups = new Map();
            hexagons.forEach(hex => {
                const key = hex.sides.join(',');
                if (!sidePatternGroups.has(key)) {
                    sidePatternGroups.set(key, []);
                }
                sidePatternGroups.get(key).push(hex);
            });
            const uniqueHexagons = Array.from(sidePatternGroups.values()).map(group => group[0]);
            return { uniqueHexagons, sidePatternGroups };
        }

        function expandArrangements(baseArrangements, sidePatternGroups) {
            if (!baseArrangements || baseArrangements.length === 0) return [];
            
            const allExpandedArrangements = [];
            const uniqueLayouts = new Set(); // Use a Set to track unique layouts

            baseArrangements.forEach(baseResult => {
                const arrangement = baseResult.arrangement;
                const slots = Object.keys(arrangement);
                const piecesInArrangement = slots.map(slot => arrangement[slot]);
                
                const pieceGroups = piecesInArrangement.map(piece => {
                    if (piece.label === 'empty') {
                        return [piece]; // This is a placeholder, treat as a group of one
                    }
                    const key = piece.sides.join(',');
                    return sidePatternGroups.get(key);
                });

                let combinations = [{}];
                for (let i = 0; i < slots.length; i++) {
                    const slot = slots[i];
                    const group = pieceGroups[i];
                    const newCombinations = [];
                    for (const hex of group) {
                        for (const combo of combinations) {
                            if (hex.label !== 'empty' && Object.values(combo).some(existingHex => existingHex.id === hex.id)) {
                                continue;
                            }
                            const newCombo = { ...combo };
                            newCombo[slot] = hex;
                            newCombinations.push(newCombo);
                        }
                    }
                    combinations = newCombinations;
                }

                combinations.forEach(finalArrangement => {
                    if (Object.keys(finalArrangement).length === slots.length) {
                        // Create a unique key for the layout based on the real pieces and their positions.
                        // Empty slots are treated as identical.
                        const layoutKey = Object.keys(finalArrangement)
                            .sort()
                            .map(slot => {
                                const piece = finalArrangement[slot];
                                return `${slot}:${piece.label === 'empty' ? 'empty' : piece.id}`;
                            })
                            .join(',');

                        if (!uniqueLayouts.has(layoutKey)) {
                            uniqueLayouts.add(layoutKey);
                            allExpandedArrangements.push({
                                arrangement: finalArrangement,
                                colorCounts: baseResult.colorCounts,
                                elementCounts: baseResult.elementCounts
                            });
                        }
                    }
                });
            });
            return allExpandedArrangements;
        }

        // --- Visualisation & UI Logic ---
        const colorMap = { 'red': '#ef4444', 'blue': '#3b82f6', 'purple': '#8b5cf6', 'gray': '#acb0b6', 'yellow': '#eab308', 'none': '#374151' };
        const rarityColor = { 'mythic': '#ef4444', 'legendary': '#eab308', 'epic': '#8b5cf6', 'uncommon': '#22c55e', 'common': '#acb0b6' };

        function getSideMidpoint(size, sideIndex) {
            const angle1 = (Math.PI / 3) * sideIndex - (5 * Math.PI / 6);
            const angle2 = (Math.PI / 3) * (sideIndex + 1) - (5 * Math.PI / 6);
            return { x: (size * Math.cos(angle1) + size * Math.cos(angle2)) / 2, y: (size * Math.sin(angle1) + size * Math.sin(angle2)) / 2 };
        }

        function drawConnections(ctx, arrangement, positions, size) {
            const connections = [
                { p1: 'T1', s1: 2, p2: 'T2', s2: 5 }, { p1: 'M1', s1: 2, p2: 'M2', s2: 5 }, { p1: 'M2', s1: 2, p2: 'M3', s2: 5 }, { p1: 'B1', s1: 2, p2: 'B2', s2: 5 },
                { p1: 'T1', s1: 4, p2: 'M1', s2: 1 }, { p1: 'T1', s1: 3, p2: 'M2', s2: 0 }, { p1: 'T2', s1: 4, p2: 'M2', s2: 1 }, { p1: 'T2', s1: 3, p2: 'M3', s2: 0 },
                { p1: 'M1', s1: 3, p2: 'B1', s2: 0 }, { p1: 'M2', s1: 4, p2: 'B1', s2: 1 }, { p1: 'M2', s1: 3, p2: 'B2', s2: 0 }, { p1: 'M3', s1: 4, p2: 'B2', s2: 1 }
            ];
            connections.forEach(({ p1, s1, p2, s2 }) => {
                const hex1 = arrangement[p1]; const hex2 = arrangement[p2];
                if (hex1 && hex2 && hex1.sides[s1] !== 'none' && hex1.sides[s1] === hex2.sides[s2]) {
                    const pos1 = positions[p1]; const pos2 = positions[p2];
                    const mid1 = getSideMidpoint(size, s1); const mid2 = getSideMidpoint(size, s2);
                    ctx.beginPath();
                    ctx.moveTo(pos1.x + mid1.x, pos1.y + mid1.y);
                    ctx.lineTo(pos2.x + mid2.x, pos2.y + mid2.y);
                    ctx.strokeStyle = colorMap[hex1.sides[s1]];
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
            });
        }

        function drawHexagon(ctx, x, y, size, hexagon) {
            ctx.save();
            ctx.translate(x, y);
            for (let i = 0; i < 6; i++) {
                const angle1 = (Math.PI / 3) * i - (5 * Math.PI / 6);
                const angle2 = (Math.PI / 3) * (i + 1) - (5 * Math.PI / 6);
                const x1 = size * Math.cos(angle1); const y1 = size * Math.sin(angle1);
                const x2 = size * Math.cos(angle2); const y2 = size * Math.sin(angle2);
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.strokeStyle = colorMap[hexagon.sides[i]];
                ctx.lineWidth = 10;
                ctx.stroke();
            }
            ctx.fillStyle = rarityColor[hexagon.rarity];
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.font = 'bold 12px Inter';
            ctx.fillText(hexagon.label, 0, -12);
            ctx.font = '10px Inter';
            ctx.fillText(`(ID: ${hexagon.id})`, 0, 0);
            if (hexagon.element && hexagon.element !== 'none') {
                ctx.fillStyle = elementColors[hexagon.element] || '#ffffff';
                ctx.font = 'bold 10px Inter';
                ctx.fillText(hexagon.element.toUpperCase(), 0, 12);
            }
            ctx.restore();
        }

        function drawArrangement(ctx, arrangement, title) {
            const canvas = ctx.canvas;
            const centerX = canvas.width / 2; const centerY = canvas.height / 2;
            const size = 45; const spacingFactor = 1.15;
            const widthBetween = size * Math.sqrt(3) * spacingFactor;
            const heightBetween = size * 1.5 * spacingFactor;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (!arrangement) {
                ctx.fillStyle = 'white'; ctx.font = '20px Inter'; ctx.textAlign = 'center';
                ctx.fillText(title, centerX, centerY);
                return;
            }
            const positions = {
                M2: { x: centerX, y: centerY }, M1: { x: centerX - widthBetween, y: centerY }, M3: { x: centerX + widthBetween, y: centerY },
                T1: { x: centerX - widthBetween / 2, y: centerY - heightBetween }, T2: { x: centerX + widthBetween / 2, y: centerY - heightBetween },
                B1: { x: centerX - widthBetween / 2, y: centerY + heightBetween }, B2: { x: centerX + widthBetween / 2, y: centerY + heightBetween }
            };
            drawConnections(ctx, arrangement, positions, size);
            for (const key in arrangement) {
                const hexagon = arrangement[key]; const pos = positions[key];
                if (hexagon && pos) { drawHexagon(ctx, pos.x, pos.y, size, hexagon); }
            }
        }

        // --- UI Helper Functions ---
        let hexagonObjects = [];  // All hexagon objects
        let selectedPoolIds = new Set();  // Shapes in the selected pool
        let tempSelectedIds = new Set();  // Temporarily selected shapes for transfer
        
        function showToast(message, type = 'info', duration = 3000) {
            const toastContainer = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.innerHTML = `
                <span>${message}</span>
                <button onclick="this.parentElement.remove()" style="margin-left: 10px; background: none; border: none; color: white; cursor: pointer; font-size: 1.2em;">&times;</button>
            `;
            toastContainer.appendChild(toast);
            
            // Trigger animation
            setTimeout(() => toast.classList.add('show'), 10);
            
            // Auto-remove after duration
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => toast.remove(), 300);
            }, duration);
        }

        function updatePoolCounters() {
            const availableCounter = document.getElementById('available-counter');
            const selectedCounter = document.getElementById('selected-counter');
            
            const availableCount = hexagonObjects.filter(h => !selectedPoolIds.has(h.id)).length;
            const selectedCount = selectedPoolIds.size;
            
            availableCounter.textContent = `Count: ${availableCount}`;
            selectedCounter.textContent = `Count: ${selectedCount}`;
        }

        // --- Main Execution ---
        window.onload = () => {
            const scoreEl = document.getElementById('score');
            const selectEl = document.getElementById('center-piece-select');
            const solveBtn = document.getElementById('solve-button');
            const scoreEl2 = document.getElementById('score2');
            const secondGridContainer = document.getElementById('second-grid-container');
            const progressContainer = document.getElementById('progress-container');
            const progressBar = document.getElementById('progress-bar');
            const progressText = document.getElementById('progress-text');
            const progressContainer2 = document.getElementById('progress-container2');
            const progressBar2 = document.getElementById('progress-bar2');
            const progressText2 = document.getElementById('progress-text2');
            const colorPriorityControls = document.getElementById('color-priority-controls');
            const elementPriorityControls = document.getElementById('element-priority-controls');
            const tiebreakFieldset = document.getElementById('tiebreak-fieldset');
            const resultsSummary1 = document.getElementById('results-summary1');
            const resultsSummary2 = document.getElementById('results-summary2');
            const addShapeBtn = document.getElementById('add-shape-button');
            const addRandomShapeBtn = document.getElementById('add-random-shape-button');
            const availableShapesEl = document.getElementById('available-shapes');
            const selectedShapesEl = document.getElementById('selected-shapes');
            const moveToSelectedBtn = document.getElementById('move-to-selected');
            const moveToAvailableBtn = document.getElementById('move-to-available');
            const moveAllToSelectedBtn = document.getElementById('move-all-to-selected');
            const moveAllToAvailableBtn = document.getElementById('move-all-to-available');
            const shapeSizeSlider = document.getElementById('shape-size-slider');
            const shapeSizeValue = document.getElementById('shape-size-value');

            let allBestLayoutsGrid1 = [];
            let allBestLayoutsGrid2 = [];
            let currentPageGrid1 = 1;
            let currentPageGrid2 = 1;
            const LAYOUTS_PER_PAGE = 9;

            function saveHexagonsToStorage() {
                localStorage.setItem('hexagonPool', JSON.stringify(hexagonObjects));
            }

            function loadHexagonsFromStorage() {
                const savedHexagons = localStorage.getItem('hexagonPool');
                if (savedHexagons) {
                    const parsedHexagons = JSON.parse(savedHexagons);
                    return parsedHexagons.map(h => new Hexagon(h.id, h.label, h.rarity, h.sides, h.element));
                }
                return [];
            }

            function updateEstimationText() {
                const estimationEl = document.getElementById('estimation-text1');
                if (!estimationEl) return;

                const selectedValue = document.getElementById('center-piece-select').value;
                const centerId = selectedValue === "any" ? null : parseInt(selectedValue, 10);
                const { uniqueHexagons } = preprocessHexagons(hexagonObjects);
                
                const selectedCount = selectedPoolIds.size;
                const slotsToFill = centerId ? 6 : 7;
                const solveError = document.getElementById('solve-error');
                const solveHint = document.getElementById('solve-button-hint');

                let pieceCount, numToChoose;

                if (selectedCount > 0) {
                    // Use only shapes in the selected pool
                    const selectedPool = uniqueHexagons.filter(h => selectedPoolIds.has(h.id) && h.id !== centerId);
                    pieceCount = selectedPool.length;
                    numToChoose = Math.min(slotsToFill, pieceCount);
                    
                    // Allow solving with less than 7 pieces - empty slots will be added
                    if (pieceCount < slotsToFill) {
                         estimationEl.textContent = `Note: Only ${pieceCount} shape(s) selected. ${slotsToFill - pieceCount} slot(s) will remain empty.`;
                         solveError.style.display = 'none';
                         solveBtn.disabled = false;
                         solveHint.textContent = `This will optimize the arrangement with ${pieceCount} shape(s) and ${slotsToFill - pieceCount} empty slot(s).`;
                         const totalSecondsStr = estimateTime(pieceCount, numToChoose);
                         estimationEl.textContent += ` Estimated time: ${formatSeconds(totalSecondsStr)}`;
                         return;
                    }

                } else {
                    // No shapes in selected pool - cannot solve
                    estimationEl.textContent = '';
                    solveError.textContent = "No shapes in the selected pool. Move shapes from the available pool to the selected pool.";
                    solveError.style.display = 'block';
                    solveBtn.disabled = true;
                    solveHint.textContent = 'Move shapes to the selected pool to enable solving.';
                    return;
                }

                solveBtn.disabled = false;
                solveError.style.display = 'none';
                solveHint.textContent = 'This will start the search for the best arrangement using shapes from the selected pool.';
                const totalSecondsStr = estimateTime(pieceCount, numToChoose);
                estimationEl.textContent = `Estimated time: ${formatSeconds(totalSecondsStr)}`;
            }

            function setupInitialData() {
                hexagonObjects = loadHexagonsFromStorage();
                selectedPoolIds.clear();
                tempSelectedIds.clear();
                populateDropdowns();
                updateShapePools();
                populateAddShapeForm();
                updateEstimationText();
                updatePoolCounters();
            }

            function addHexagon() {
                const id = parseInt(document.getElementById('new-hex-id').value, 10);
                const label = document.getElementById('new-hex-label').value;
                const rarity = document.getElementById('new-hex-rarity').value;
                const element = document.getElementById('new-hex-element').value;
                const sides = Array.from(document.querySelectorAll('#new-hex-sides select')).map(s => s.value);

                if (!label || !rarity) {
                    showToast('Please fill all fields for the new hexagon.', 'warning');
                    return;
                }

                const newHex = new Hexagon(id, label, rarity, sides, element);
                hexagonObjects.push(newHex);
                saveHexagonsToStorage();
                populateDropdowns();
                updateShapePools();
                updateEstimationText();
                updatePoolCounters();
                
                document.getElementById('new-hex-label').value = '';
                document.getElementById('new-hex-id').value = getNextId();
                showToast('Hexagon added successfully!', 'success');
            }

            function addRandomHexagon() {
                const rarities = Object.keys(rarityValue).filter(r => r !== 'none');
                const colors = Object.keys(colorMap);

                document.getElementById('new-hex-id').value = getNextId();
                document.getElementById('new-hex-label').value = `random_${Math.random().toString(36).substring(2, 7)}`;
                document.getElementById('new-hex-rarity').value = rarities[Math.floor(Math.random() * rarities.length)];
                document.getElementById('new-hex-element').value = elements[Math.floor(Math.random() * elements.length)];
                
                const sideSelectors = document.querySelectorAll('#new-hex-sides select');
                sideSelectors.forEach(selector => {
                    selector.value = colors[Math.floor(Math.random() * colors.length)];
                });

                addHexagon();
            }

            function getNextId() {
                return hexagonObjects.length > 0 ? Math.max(...hexagonObjects.map(h => h.id)) + 1 : 1;
            }

            function populateAddShapeForm() {
                document.getElementById('new-hex-id').value = getNextId();
                const raritySelect = document.getElementById('new-hex-rarity');
                raritySelect.innerHTML = '';
                Object.keys(rarityValue).forEach(rarity => {
                    if (rarity === 'none') return;
                    const option = document.createElement('option');
                    option.value = rarity;
                    option.textContent = rarity.charAt(0).toUpperCase() + rarity.slice(1);
                    raritySelect.appendChild(option);
                });

                const elementSelect = document.getElementById('new-hex-element');
                elementSelect.innerHTML = '';
                elements.forEach(element => {
                    const option = document.createElement('option');
                    option.value = element;
                    option.textContent = element.charAt(0).toUpperCase() + element.slice(1);
                    elementSelect.appendChild(option);
                });

                const sidesContainer = document.getElementById('new-hex-sides');
                sidesContainer.innerHTML = '';
                for (let i = 0; i < 6; i++) {
                    const sideSelect = document.createElement('select');
                    sideSelect.className = 'bg-gray-700 border border-gray-600 rounded-md p-2 text-white';
                    Object.keys(colorMap).forEach(color => {
                        const option = document.createElement('option');
                        option.value = color;
                        option.textContent = color.charAt(0).toUpperCase() + color.slice(1);
                        sideSelect.appendChild(option);
                    });
                    sidesContainer.appendChild(sideSelect);
                }
            }

            function populateDropdowns() {
                const selectedVal = selectEl.value;
                selectEl.innerHTML = '';
                const anyOption = document.createElement('option');
                anyOption.value = "any";
                anyOption.textContent = "Any (Brute Force All)";
                selectEl.appendChild(anyOption);
                
                // Only show shapes from the selected pool
                const selectedShapes = hexagonObjects.filter(hex => selectedPoolIds.has(hex.id));
                selectedShapes.sort((a, b) => (rarityValue[b.rarity] || 0) - (rarityValue[a.rarity] || 0) || a.label.localeCompare(b.label))
                              .forEach(hex => {
                    const option = document.createElement('option');
                    option.value = hex.id;
                    option.textContent = `${hex.label} (ID: ${hex.id})`;
                    selectEl.appendChild(option);
                });
                
                // If the previously selected value is no longer in the pool, reset to "any"
                if (selectedVal && selectedVal !== "any" && !selectedPoolIds.has(parseInt(selectedVal, 10))) {
                    selectEl.value = "any";
                } else {
                    selectEl.value = selectedVal;
                }
            }

            function updateShapePools() {
                availableShapesEl.innerHTML = '';
                selectedShapesEl.innerHTML = '';
                
                // Get current size from slider
                const shapeSize = parseInt(shapeSizeSlider.value);
                const hexSize = shapeSize * 0.357; // Proportional to canvas size (50/140)
                const centerPos = shapeSize / 2;
                
                hexagonObjects.forEach(hex => {
                    const hexContainer = document.createElement('div');
                    hexContainer.className = 'relative shape-pool-item';
                    hexContainer.dataset.hexId = hex.id;
                    
                    // Check if temporarily selected for transfer
                    if (tempSelectedIds.has(hex.id)) {
                        hexContainer.classList.add('selected');
                    }

                    const canvas = document.createElement('canvas');
                    canvas.width = shapeSize;
                    canvas.height = shapeSize;
                    canvas.className = 'rounded-lg border-2 cursor-pointer';
                    canvas.style.borderColor = rarityColor[hex.rarity] || '#374151';
                    const ctx = canvas.getContext('2d');
                    drawHexagon(ctx, centerPos, centerPos, hexSize, hex);

                    canvas.addEventListener('click', () => {
                        // Toggle selection for transfer
                        if (tempSelectedIds.has(hex.id)) {
                            tempSelectedIds.delete(hex.id);
                            hexContainer.classList.remove('selected');
                        } else {
                            tempSelectedIds.add(hex.id);
                            hexContainer.classList.add('selected');
                        }
                    });

                    const deleteBtn = document.createElement('button');
                    deleteBtn.textContent = 'X';
                    deleteBtn.className = 'absolute top-0 right-0 bg-red-600 hover:bg-red-700 text-white font-bold w-6 h-6 rounded-full flex items-center justify-center text-xs z-10';
                    deleteBtn.onclick = (e) => {
                        e.stopPropagation();
                        if (confirm(`Are you sure you want to delete hexagon "${hex.label}"?`)) {
                            deleteHexagon(hex.id);
                        }
                    };
                    
                    hexContainer.appendChild(canvas);
                    hexContainer.appendChild(deleteBtn);
                    
                    // Add to appropriate pool
                    if (selectedPoolIds.has(hex.id)) {
                        selectedShapesEl.appendChild(hexContainer);
                    } else {
                        availableShapesEl.appendChild(hexContainer);
                    }
                });
                
                updatePoolCounters();
            }

            function deleteHexagon(id) {
                selectedPoolIds.delete(id);
                tempSelectedIds.delete(id);
                const index = hexagonObjects.findIndex(h => h.id === id);
                if (index > -1) {
                    const deletedHex = hexagonObjects[index];
                    hexagonObjects.splice(index, 1);
                    saveHexagonsToStorage();
                    updateShapePools();
                    populateDropdowns();  // This will now only show shapes from selected pool
                    document.getElementById('new-hex-id').value = getNextId();
                    updateEstimationText();
                    updatePoolCounters();
                    showToast(`Hexagon "${deletedHex.label}" deleted successfully.`, 'success');
                }
            }

            addShapeBtn.addEventListener('click', addHexagon);
            addRandomShapeBtn.addEventListener('click', addRandomHexagon);
            selectEl.addEventListener('change', () => {
                updateEstimationText();
            });
            
            // Add event listeners for transfer buttons
            moveToSelectedBtn.addEventListener('click', () => {
                tempSelectedIds.forEach(id => {
                    selectedPoolIds.add(id);
                });
                tempSelectedIds.clear();
                updateShapePools();
                populateDropdowns();  // Update center piece dropdown
                updateEstimationText();
            });
            
            moveToAvailableBtn.addEventListener('click', () => {
                tempSelectedIds.forEach(id => {
                    selectedPoolIds.delete(id);
                });
                tempSelectedIds.clear();
                updateShapePools();
                populateDropdowns();  // Update center piece dropdown
                updateEstimationText();
            });
            
            // Add event listeners for move all buttons
            moveAllToSelectedBtn.addEventListener('click', () => {
                // Move all shapes to selected pool
                hexagonObjects.forEach(hex => {
                    selectedPoolIds.add(hex.id);
                });
                tempSelectedIds.clear();
                updateShapePools();
                populateDropdowns();  // Update center piece dropdown
                updateEstimationText();
                showToast('All Toyz moved to battle position!', 'success');
            });
            
            moveAllToAvailableBtn.addEventListener('click', () => {
                // Move all shapes to available pool
                selectedPoolIds.clear();
                tempSelectedIds.clear();
                updateShapePools();
                populateDropdowns();  // Update center piece dropdown
                updateEstimationText();
                showToast('All Toyz returned to inventory!', 'success');
            });

            const colors = ['red', 'blue', 'purple', 'gray', 'yellow'];
            for(let i = 1; i <= 3; i++) {
                const prioritySelect = document.createElement('select');
                prioritySelect.id = `color-priority-${i}`;
                prioritySelect.className = "bg-gray-700 border border-gray-600 text-white rounded-md p-2";
                const defaultOption = document.createElement('option');
                defaultOption.value = "none";
                defaultOption.textContent = i === 1 ? '1st' : (i === 2 ? '2nd' : '3rd');
                prioritySelect.appendChild(defaultOption);
                colors.forEach(c => {
                    const opt = document.createElement('option');
                    opt.value = c;
                    opt.textContent = c.charAt(0).toUpperCase() + c.slice(1);
                    prioritySelect.appendChild(opt);
                });
                colorPriorityControls.appendChild(prioritySelect);
            }

            for(let i = 1; i <= 3; i++) {
                const prioritySelect = document.createElement('select');
                prioritySelect.id = `element-priority-${i}`;
                prioritySelect.className = "bg-gray-700 border border-gray-600 text-white rounded-md p-2";
                const defaultOption = document.createElement('option');
                defaultOption.value = "none";
                defaultOption.textContent = i === 1 ? '1st' : (i === 2 ? '2nd' : '3rd');
                prioritySelect.appendChild(defaultOption);
                elements.forEach(e => {
                    const opt = document.createElement('option');
                    opt.value = e;
                    opt.textContent = e.charAt(0).toUpperCase() + e.slice(1);
                    prioritySelect.appendChild(opt);
                });
                elementPriorityControls.appendChild(prioritySelect);
            }

            function updateDisplay(gridNum, bestLayouts, page = 1) {
                if (gridNum === 1) currentPageGrid1 = page;
                if (gridNum === 2) currentPageGrid2 = page;

                const gridLayoutContainer = document.getElementById(`grid${gridNum}-layouts`);
                const paginationContainer = document.getElementById(`grid${gridNum}-pagination`);
                gridLayoutContainer.innerHTML = '';
                paginationContainer.innerHTML = '';

                const tiebreakMode = document.querySelector('input[name="tiebreak-mode"]:checked').value;
                const colorPriority = [];
                const elementPriority = [];

                if (tiebreakMode === 'color') {
                    for(let i = 1; i <= 3; i++) {
                        const val = document.getElementById(`color-priority-${i}`).value;
                        if (val !== 'none') colorPriority.push(val);
                    }
                } else if (tiebreakMode === 'element') {
                    for(let i = 1; i <= 3; i++) {
                        const val = document.getElementById(`element-priority-${i}`).value;
                        if (val !== 'none') elementPriority.push(val);
                    }
                }
                const sortedLayouts = applyTieBreaking(bestLayouts, tiebreakMode, colorPriority, elementPriority);
                
                const totalPages = Math.ceil(sortedLayouts.length / LAYOUTS_PER_PAGE);
                const startIndex = (page - 1) * LAYOUTS_PER_PAGE;
                const endIndex = startIndex + LAYOUTS_PER_PAGE;
                const paginatedLayouts = sortedLayouts.slice(startIndex, endIndex);

                paginatedLayouts.forEach((layout, index) => {
                    const originalIndex = startIndex + index;
                    const container = document.createElement('div');
                    container.className = 'layout-container';
                    container.dataset.layoutIndex = originalIndex;

                    if (gridNum === 1) {
                        container.addEventListener('click', () => {
                            const selected = document.querySelector(`#grid1-layouts .layout-container.selected`);
                            if (selected) selected.classList.remove('selected');
                            container.classList.add('selected');
                            document.getElementById('solve-second-grid-button').disabled = false;
                        });
                    }

                    const title = document.createElement('h3');
                    title.className = 'font-semibold text-lg';
                    title.textContent = `Layout #${originalIndex + 1}`;
                    container.appendChild(title);

                    const canvas = document.createElement('canvas');
                    canvas.width = 400;
                    canvas.height = 400;
                    container.appendChild(canvas);

                    const summaryDiv = document.createElement('div');
                    summaryDiv.className = 'text-xs mt-2';
                    container.appendChild(summaryDiv);

                    gridLayoutContainer.appendChild(container);

                    drawArrangement(canvas.getContext('2d'), layout.arrangement, 'Error');
                    
                    let summaryHTML = '<div>';
                    for (const color in layout.colorCounts) {
                        if (layout.colorCounts[color] > 0) {
                            summaryHTML += `<span class="inline-block mx-2" style="color:${colorMap[color]}">${color.charAt(0).toUpperCase() + color.slice(1)}: ${layout.colorCounts[color]}</span>`;
                        }
                    }
                    summaryHTML += '</div><div class="mt-1">';
                     for (const element in layout.elementCounts) {
                        if (layout.elementCounts[element] > 0) {
                            summaryHTML += `<span class="inline-block mx-2" style="color:${elementColors[element] || '#fff'}">${element.charAt(0).toUpperCase() + element.slice(1)}: ${layout.elementCounts[element]}</span>`;
                        }
                    }
                    summaryHTML += '</div>';
                    summaryDiv.innerHTML = summaryHTML;
                });

                if (totalPages > 1) {
                    const createButton = (text, pageNum, isDisabled = false, isCurrent = false, isEllipsis = false) => {
                        const button = document.createElement('button');
                        button.innerHTML = text;
                        let classes = 'py-2 px-4 font-bold text-white';
                        if (isEllipsis) {
                            classes += ' bg-gray-600 cursor-default';
                        } else if (isCurrent) {
                            classes += ' current-page';
                        } else if (isDisabled) {
                            classes += ' bg-gray-600 opacity-50 cursor-not-allowed';
                        } else {
                            classes += ' bg-gray-600 hover:bg-gray-700';
                        }
                        button.className = classes;
                        if (!isDisabled && !isCurrent && !isEllipsis) {
                            button.addEventListener('click', () => updateDisplay(gridNum, bestLayouts, pageNum));
                        }
                        return button;
                    };

                    const prevButton = createButton('&larr;', page - 1, page === 1);
                    prevButton.classList.add('rounded-l-md');
                    paginationContainer.appendChild(prevButton);

                    const pagesToShow = [];
                    if (totalPages <= 7) {
                        for (let i = 1; i <= totalPages; i++) {
                            pagesToShow.push(i);
                        }
                    } else {
                        pagesToShow.push(1);
                        if (page > 3) pagesToShow.push('...');
                        if (page > 2) pagesToShow.push(page - 1);
                        if (page !== 1 && page !== totalPages) pagesToShow.push(page);
                        if (page < totalPages - 1) pagesToShow.push(page + 1);
                        if (page < totalPages - 2) pagesToShow.push('...');
                        pagesToShow.push(totalPages);
                    }
                    
                    [...new Set(pagesToShow)].forEach(p => {
                        paginationContainer.appendChild(p === '...' ? createButton('...', 0, false, false, true) : createButton(p, p, false, p === page));
                    });
                    
                    const nextButton = createButton('&rarr;', page + 1, page === totalPages);
                    nextButton.classList.add('rounded-r-md');
                    paginationContainer.appendChild(nextButton);
                }
            }

            tiebreakFieldset.addEventListener('change', () => {
                const tiebreakMode = document.querySelector('input[name="tiebreak-mode"]:checked').value;
                colorPriorityControls.style.display = tiebreakMode === 'color' ? 'flex' : 'none';
                elementPriorityControls.style.display = tiebreakMode === 'element' ? 'flex' : 'none';
                updateDisplay(1, allBestLayoutsGrid1, 1);
                updateDisplay(2, allBestLayoutsGrid2, 1);
            });

            const runSolver = async () => {
                solveBtn.disabled = true;
                tiebreakFieldset.disabled = true;
                document.getElementById('solve-second-grid-button').style.display = 'none';
                secondGridContainer.style.display = 'none';
                document.getElementById('grid1-layouts').innerHTML = '';
                document.getElementById('grid2-layouts').innerHTML = '';
                document.getElementById('grid1-pagination').innerHTML = '';
                document.getElementById('grid2-pagination').innerHTML = '';
                document.getElementById('grid1-title').style.display = 'none';

                scoreEl.textContent = 'Calculating...';
                resultsSummary1.textContent = '';
                progressContainer.style.display = 'block';
                progressBar.style.width = '0%';

                const selectedValue = selectEl.value;
                const centerId = selectedValue === "any" ? null : parseInt(selectedValue, 10);
                const searchMode = document.querySelector('input[name="search-mode"]:checked').value;

                const { uniqueHexagons, sidePatternGroups } = preprocessHexagons(hexagonObjects);

                // Use only the shapes in the selected pool
                let pool = uniqueHexagons.filter(h => selectedPoolIds.has(h.id));
                const forcedIds = new Set();
                
                // If a center piece is selected, ensure it's in the pool
                if (centerId) {
                    const centerHexInPool = pool.find(h => h.id === centerId);
                    if (!centerHexInPool) {
                        const centerHex = uniqueHexagons.find(h => h.id === centerId);
                        if (centerHex) {
                            pool.push(centerHex);
                        }
                    }
                }

                const estimationText1 = document.getElementById('estimation-text1');
                
                const totalSecondsStr = estimationText1.textContent.replace('Estimated time: ', '');
                
                const { score, arrangements: baseArrangements } = await findAllBestArrangements(pool, centerId, searchMode, (progress, count, total) => {
                    progressBar.style.width = `${progress * 100}%`;
                    const remainingSecondsStr = multiplyBigInt(totalSecondsStr, Math.round((1 - progress) * 100));
                    const finalSecondsStr = divideBigInt(remainingSecondsStr, 100).quotient;
                    estimationText1.textContent = `Time remaining: ${formatSeconds(finalSecondsStr)}`;

                    progressText.textContent = total > 0 
                        ? `Checked ${count.toLocaleString()} / ${total.toLocaleString()} permutations...`
                        : `Evaluated ${count.toLocaleString()} arrangements...`;
                }, forcedIds);
                
                const arrangements = expandArrangements(baseArrangements, sidePatternGroups);
                allBestLayoutsGrid1 = arrangements;
                progressContainer.style.display = 'none';
                progressText.textContent = '';
                scoreEl.textContent = `Maximum Stat Boost Score: ${score}`;
                resultsSummary1.textContent = `Found ${arrangements.length} layout(s) with this score.`;
                updateEstimationText();
                
                if (arrangements.length > 0) {
                    document.getElementById('grid1-title').style.display = 'block';
                    updateDisplay(1, allBestLayoutsGrid1, 1);
                    document.getElementById('solve-second-grid-button').style.display = 'none';
                    document.getElementById('solve-second-grid-hint').style.display = 'none';
                } else {
                    scoreEl.textContent += ' - No arrangements found.';
                }

                solveBtn.disabled = false;
                tiebreakFieldset.disabled = false;
            };

            const runSecondGridSolver = async () => {
                const selectedLayoutElement = document.querySelector('#grid1-layouts .layout-container.selected');
                if (!selectedLayoutElement) {
                    showToast('Please select a layout from the main grid first.', 'warning');
                    return;
                }

                document.getElementById('solve-second-grid-button').disabled = true;
                secondGridContainer.style.display = 'block';
                scoreEl2.innerHTML = `<h2 class="text-xl font-semibold text-gray-300 mt-4">Second Grid</h2>Calculating...`;
                resultsSummary2.textContent = '';
                progressContainer2.style.display = 'block';
                progressBar2.style.width = '0%';
                document.getElementById('grid2-layouts').innerHTML = '';
                document.getElementById('grid2-pagination').innerHTML = '';

                const selectedLayoutIndex = parseInt(selectedLayoutElement.dataset.layoutIndex, 10);
                const sortedLayouts = applyTieBreaking(allBestLayoutsGrid1, document.querySelector('input[name="tiebreak-mode"]:checked').value);
                const selectedLayout = sortedLayouts[selectedLayoutIndex];
                const usedIds = new Set(Object.values(selectedLayout.arrangement).map(hex => hex.id));
                const remainingHexagons = hexagonObjects.filter(hex => !usedIds.has(hex.id));
                const searchMode = document.querySelector('input[name="search-mode"]:checked').value;
                const estimationText2 = document.getElementById('estimation-text2');
                const numToChooseForSecondGrid = Math.min(remainingHexagons.length, 7);

                if (numToChooseForSecondGrid > 0) {
                    const { uniqueHexagons: uniqueRemaining, sidePatternGroups: remainingGroups } = preprocessHexagons(remainingHexagons);
                    if (uniqueRemaining.length > 0) {
                        const totalSecondsStr2 = estimateTime(uniqueRemaining.length, numToChooseForSecondGrid);
                        estimationText2.textContent = `Estimated time: ${formatSeconds(totalSecondsStr2)}`;

                        const { score: score2, arrangements: baseArrangements2 } = await findAllBestArrangements(uniqueRemaining, null, searchMode, (progress, count, total) => {
                            progressBar2.style.width = `${progress * 100}%`;
                            const remainingSecondsStr = multiplyBigInt(totalSecondsStr2, Math.round((1 - progress) * 100));
                            const finalSecondsStr = divideBigInt(remainingSecondsStr, 100).quotient;
                            estimationText2.textContent = `Time remaining: ${formatSeconds(finalSecondsStr)}`;

                            progressText2.textContent = total > 0
                                ? `Checked ${count.toLocaleString()} / ${total.toLocaleString()} permutations...`
                                : `Evaluated ${count.toLocaleString()} arrangements...`;
                        });

                        const arrangements2 = expandArrangements(baseArrangements2, remainingGroups);
                        allBestLayoutsGrid2 = arrangements2;
                        scoreEl2.innerHTML = `<h2 class="text-xl font-semibold text-gray-300 mt-4">Second Grid</h2>Maximum Stat Boost Score: ${score2}`;
                        resultsSummary2.textContent = `Found ${arrangements2.length} layout(s) with this score.`;
                        estimationText2.textContent = '';
                        updateDisplay(2, allBestLayoutsGrid2, 1);
                    } else {
                        scoreEl2.innerHTML = `<h2 class="text-xl font-semibold text-gray-300 mt-4">Second Grid</h2>`;
                        resultsSummary2.textContent = 'Not enough unique pieces for a second grid.';
                    }
                } else {
                    scoreEl2.innerHTML = `<h2 class="text-xl font-semibold text-gray-300 mt-4">Second Grid</h2>`;
                    resultsSummary2.textContent = 'Not enough pieces for a second grid.';
                }
                progressContainer2.style.display = 'none';
                progressText2.textContent = '';
                document.getElementById('solve-second-grid-button').disabled = false;
            };

            scoreEl.textContent = 'Select an option and click Solve to begin.';
            document.getElementById('grid1-layouts').innerHTML = '';
            document.getElementById('grid2-layouts').innerHTML = '';

            solveBtn.addEventListener('click', runSolver);
            document.getElementById('solve-second-grid-button').addEventListener('click', runSecondGridSolver);

            // Add shape size slider event listener
            shapeSizeSlider.addEventListener('input', (e) => {
                const size = e.target.value;
                shapeSizeValue.textContent = `${size}px`;
                updateShapePools();
            });
            
            setupInitialData();
        };
    </script>
</body>
</html>
